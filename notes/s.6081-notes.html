<!DOCTYPE html><html><head>
      <title>notes</title>
      <meta charset="utf-8">
      <meta name="viewport" content="width=device-width, initial-scale=1.0">
      
      <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.4/dist/katex.min.css" crossorigin="anonymous">
      
      
      
      
      
      <style>
      code[class*=language-],pre[class*=language-]{color:#333;background:0 0;font-family:Consolas,"Liberation Mono",Menlo,Courier,monospace;text-align:left;white-space:pre;word-spacing:normal;word-break:normal;word-wrap:normal;line-height:1.4;-moz-tab-size:8;-o-tab-size:8;tab-size:8;-webkit-hyphens:none;-moz-hyphens:none;-ms-hyphens:none;hyphens:none}pre[class*=language-]{padding:.8em;overflow:auto;border-radius:3px;background:#f5f5f5}:not(pre)>code[class*=language-]{padding:.1em;border-radius:.3em;white-space:normal;background:#f5f5f5}.token.blockquote,.token.comment{color:#969896}.token.cdata{color:#183691}.token.doctype,.token.macro.property,.token.punctuation,.token.variable{color:#333}.token.builtin,.token.important,.token.keyword,.token.operator,.token.rule{color:#a71d5d}.token.attr-value,.token.regex,.token.string,.token.url{color:#183691}.token.atrule,.token.boolean,.token.code,.token.command,.token.constant,.token.entity,.token.number,.token.property,.token.symbol{color:#0086b3}.token.prolog,.token.selector,.token.tag{color:#63a35c}.token.attr-name,.token.class,.token.class-name,.token.function,.token.id,.token.namespace,.token.pseudo-class,.token.pseudo-element,.token.url-reference .token.variable{color:#795da3}.token.entity{cursor:help}.token.title,.token.title .token.punctuation{font-weight:700;color:#1d3e81}.token.list{color:#ed6a43}.token.inserted{background-color:#eaffea;color:#55a532}.token.deleted{background-color:#ffecec;color:#bd2c00}.token.bold{font-weight:700}.token.italic{font-style:italic}.language-json .token.property{color:#183691}.language-markup .token.tag .token.punctuation{color:#333}.language-css .token.function,code.language-css{color:#0086b3}.language-yaml .token.atrule{color:#63a35c}code.language-yaml{color:#183691}.language-ruby .token.function{color:#333}.language-markdown .token.url{color:#795da3}.language-makefile .token.symbol{color:#795da3}.language-makefile .token.variable{color:#183691}.language-makefile .token.builtin{color:#0086b3}.language-bash .token.keyword{color:#0086b3}pre[data-line]{position:relative;padding:1em 0 1em 3em}pre[data-line] .line-highlight-wrapper{position:absolute;top:0;left:0;background-color:transparent;display:block;width:100%}pre[data-line] .line-highlight{position:absolute;left:0;right:0;padding:inherit 0;margin-top:1em;background:hsla(24,20%,50%,.08);background:linear-gradient(to right,hsla(24,20%,50%,.1) 70%,hsla(24,20%,50%,0));pointer-events:none;line-height:inherit;white-space:pre}pre[data-line] .line-highlight:before,pre[data-line] .line-highlight[data-end]:after{content:attr(data-start);position:absolute;top:.4em;left:.6em;min-width:1em;padding:0 .5em;background-color:hsla(24,20%,50%,.4);color:#f4f1ef;font:bold 65%/1.5 sans-serif;text-align:center;vertical-align:.3em;border-radius:999px;text-shadow:none;box-shadow:0 1px #fff}pre[data-line] .line-highlight[data-end]:after{content:attr(data-end);top:auto;bottom:.4em}html body{font-family:'Helvetica Neue',Helvetica,'Segoe UI',Arial,freesans,sans-serif;font-size:16px;line-height:1.6;color:#333;background-color:#fff;overflow:initial;box-sizing:border-box;word-wrap:break-word}html body>:first-child{margin-top:0}html body h1,html body h2,html body h3,html body h4,html body h5,html body h6{line-height:1.2;margin-top:1em;margin-bottom:16px;color:#000}html body h1{font-size:2.25em;font-weight:300;padding-bottom:.3em}html body h2{font-size:1.75em;font-weight:400;padding-bottom:.3em}html body h3{font-size:1.5em;font-weight:500}html body h4{font-size:1.25em;font-weight:600}html body h5{font-size:1.1em;font-weight:600}html body h6{font-size:1em;font-weight:600}html body h1,html body h2,html body h3,html body h4,html body h5{font-weight:600}html body h5{font-size:1em}html body h6{color:#5c5c5c}html body strong{color:#000}html body del{color:#5c5c5c}html body a:not([href]){color:inherit;text-decoration:none}html body a{color:#08c;text-decoration:none}html body a:hover{color:#00a3f5;text-decoration:none}html body img{max-width:100%}html body>p{margin-top:0;margin-bottom:16px;word-wrap:break-word}html body>ol,html body>ul{margin-bottom:16px}html body ol,html body ul{padding-left:2em}html body ol.no-list,html body ul.no-list{padding:0;list-style-type:none}html body ol ol,html body ol ul,html body ul ol,html body ul ul{margin-top:0;margin-bottom:0}html body li{margin-bottom:0}html body li.task-list-item{list-style:none}html body li>p{margin-top:0;margin-bottom:0}html body .task-list-item-checkbox{margin:0 .2em .25em -1.8em;vertical-align:middle}html body .task-list-item-checkbox:hover{cursor:pointer}html body blockquote{margin:16px 0;font-size:inherit;padding:0 15px;color:#5c5c5c;background-color:#f0f0f0;border-left:4px solid #d6d6d6}html body blockquote>:first-child{margin-top:0}html body blockquote>:last-child{margin-bottom:0}html body hr{height:4px;margin:32px 0;background-color:#d6d6d6;border:0 none}html body table{margin:10px 0 15px 0;border-collapse:collapse;border-spacing:0;display:block;width:100%;overflow:auto;word-break:normal;word-break:keep-all}html body table th{font-weight:700;color:#000}html body table td,html body table th{border:1px solid #d6d6d6;padding:6px 13px}html body dl{padding:0}html body dl dt{padding:0;margin-top:16px;font-size:1em;font-style:italic;font-weight:700}html body dl dd{padding:0 16px;margin-bottom:16px}html body code{font-family:Menlo,Monaco,Consolas,'Courier New',monospace;font-size:.85em;color:#000;background-color:#f0f0f0;border-radius:3px;padding:.2em 0}html body code::after,html body code::before{letter-spacing:-.2em;content:'\00a0'}html body pre>code{padding:0;margin:0;word-break:normal;white-space:pre;background:0 0;border:0}html body .highlight{margin-bottom:16px}html body .highlight pre,html body pre{padding:1em;overflow:auto;line-height:1.45;border:#d6d6d6;border-radius:3px}html body .highlight pre{margin-bottom:0;word-break:normal}html body pre code,html body pre tt{display:inline;max-width:initial;padding:0;margin:0;overflow:initial;line-height:inherit;word-wrap:normal;background-color:transparent;border:0}html body pre code:after,html body pre code:before,html body pre tt:after,html body pre tt:before{content:normal}html body blockquote,html body dl,html body ol,html body p,html body pre,html body ul{margin-top:0;margin-bottom:16px}html body kbd{color:#000;border:1px solid #d6d6d6;border-bottom:2px solid #c7c7c7;padding:2px 4px;background-color:#f0f0f0;border-radius:3px}@media print{html body{background-color:#fff}html body h1,html body h2,html body h3,html body h4,html body h5,html body h6{color:#000;page-break-after:avoid}html body blockquote{color:#5c5c5c}html body pre{page-break-inside:avoid}html body table{display:table}html body img{display:block;max-width:100%;max-height:100%}html body code,html body pre{word-wrap:break-word;white-space:pre}}.markdown-preview{width:100%;height:100%;box-sizing:border-box}.markdown-preview ul{list-style:disc}.markdown-preview ul ul{list-style:circle}.markdown-preview ul ul ul{list-style:square}.markdown-preview ol{list-style:decimal}.markdown-preview ol ol,.markdown-preview ul ol{list-style-type:lower-roman}.markdown-preview ol ol ol,.markdown-preview ol ul ol,.markdown-preview ul ol ol,.markdown-preview ul ul ol{list-style-type:lower-alpha}.markdown-preview .newpage,.markdown-preview .pagebreak{page-break-before:always}.markdown-preview pre.line-numbers{position:relative;padding-left:3.8em;counter-reset:linenumber}.markdown-preview pre.line-numbers>code{position:relative}.markdown-preview pre.line-numbers .line-numbers-rows{position:absolute;pointer-events:none;top:1em;font-size:100%;left:0;width:3em;letter-spacing:-1px;border-right:1px solid #999;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none}.markdown-preview pre.line-numbers .line-numbers-rows>span{pointer-events:none;display:block;counter-increment:linenumber}.markdown-preview pre.line-numbers .line-numbers-rows>span:before{content:counter(linenumber);color:#999;display:block;padding-right:.8em;text-align:right}.markdown-preview .mathjax-exps .MathJax_Display{text-align:center!important}.markdown-preview:not([data-for=preview]) .code-chunk .code-chunk-btn-group{display:none}.markdown-preview:not([data-for=preview]) .code-chunk .status{display:none}.markdown-preview:not([data-for=preview]) .code-chunk .output-div{margin-bottom:16px}.markdown-preview .md-toc{padding:0}.markdown-preview .md-toc .md-toc-link-wrapper .md-toc-link{display:inline;padding:.25rem 0}.markdown-preview .md-toc .md-toc-link-wrapper .md-toc-link div,.markdown-preview .md-toc .md-toc-link-wrapper .md-toc-link p{display:inline}.markdown-preview .md-toc .md-toc-link-wrapper.highlighted .md-toc-link{font-weight:800}.scrollbar-style::-webkit-scrollbar{width:8px}.scrollbar-style::-webkit-scrollbar-track{border-radius:10px;background-color:transparent}.scrollbar-style::-webkit-scrollbar-thumb{border-radius:5px;background-color:rgba(150,150,150,.66);border:4px solid rgba(150,150,150,.66);background-clip:content-box}html body[for=html-export]:not([data-presentation-mode]){position:relative;width:100%;height:100%;top:0;left:0;margin:0;padding:0;overflow:auto}html body[for=html-export]:not([data-presentation-mode]) .markdown-preview{position:relative;top:0;min-height:100vh}@media screen and (min-width:914px){html body[for=html-export]:not([data-presentation-mode]) .markdown-preview{padding:2em calc(50% - 457px + 2em)}}@media screen and (max-width:914px){html body[for=html-export]:not([data-presentation-mode]) .markdown-preview{padding:2em}}@media screen and (max-width:450px){html body[for=html-export]:not([data-presentation-mode]) .markdown-preview{font-size:14px!important;padding:1em}}@media print{html body[for=html-export]:not([data-presentation-mode]) #sidebar-toc-btn{display:none}}html body[for=html-export]:not([data-presentation-mode]) #sidebar-toc-btn{position:fixed;bottom:8px;left:8px;font-size:28px;cursor:pointer;color:inherit;z-index:99;width:32px;text-align:center;opacity:.4}html body[for=html-export]:not([data-presentation-mode])[html-show-sidebar-toc] #sidebar-toc-btn{opacity:1}html body[for=html-export]:not([data-presentation-mode])[html-show-sidebar-toc] .md-sidebar-toc{position:fixed;top:0;left:0;width:300px;height:100%;padding:32px 0 48px 0;font-size:14px;box-shadow:0 0 4px rgba(150,150,150,.33);box-sizing:border-box;overflow:auto;background-color:inherit}html body[for=html-export]:not([data-presentation-mode])[html-show-sidebar-toc] .md-sidebar-toc::-webkit-scrollbar{width:8px}html body[for=html-export]:not([data-presentation-mode])[html-show-sidebar-toc] .md-sidebar-toc::-webkit-scrollbar-track{border-radius:10px;background-color:transparent}html body[for=html-export]:not([data-presentation-mode])[html-show-sidebar-toc] .md-sidebar-toc::-webkit-scrollbar-thumb{border-radius:5px;background-color:rgba(150,150,150,.66);border:4px solid rgba(150,150,150,.66);background-clip:content-box}html body[for=html-export]:not([data-presentation-mode])[html-show-sidebar-toc] .md-sidebar-toc a{text-decoration:none}html body[for=html-export]:not([data-presentation-mode])[html-show-sidebar-toc] .md-sidebar-toc .md-toc{padding:0 16px}html body[for=html-export]:not([data-presentation-mode])[html-show-sidebar-toc] .md-sidebar-toc .md-toc .md-toc-link-wrapper .md-toc-link{display:inline;padding:.25rem 0}html body[for=html-export]:not([data-presentation-mode])[html-show-sidebar-toc] .md-sidebar-toc .md-toc .md-toc-link-wrapper .md-toc-link div,html body[for=html-export]:not([data-presentation-mode])[html-show-sidebar-toc] .md-sidebar-toc .md-toc .md-toc-link-wrapper .md-toc-link p{display:inline}html body[for=html-export]:not([data-presentation-mode])[html-show-sidebar-toc] .md-sidebar-toc .md-toc .md-toc-link-wrapper.highlighted .md-toc-link{font-weight:800}html body[for=html-export]:not([data-presentation-mode])[html-show-sidebar-toc] .markdown-preview{left:300px;width:calc(100% - 300px);padding:2em calc(50% - 457px - 300px / 2);margin:0;box-sizing:border-box}@media screen and (max-width:1274px){html body[for=html-export]:not([data-presentation-mode])[html-show-sidebar-toc] .markdown-preview{padding:2em}}@media screen and (max-width:450px){html body[for=html-export]:not([data-presentation-mode])[html-show-sidebar-toc] .markdown-preview{width:100%}}html body[for=html-export]:not([data-presentation-mode]):not([html-show-sidebar-toc]) .markdown-preview{left:50%;transform:translateX(-50%)}html body[for=html-export]:not([data-presentation-mode]):not([html-show-sidebar-toc]) .md-sidebar-toc{display:none}
/* Please visit the URL below for more information: */
/*   https://shd101wyy.github.io/markdown-preview-enhanced/#/customize-css */

      </style>
      <!-- The content below will be included at the end of the <head> element. --><script type="text/javascript">
  document.addEventListener("DOMContentLoaded", function () {
    // your code here
  });
</script></head><body for="html-export">
    
    
      <div class="crossnote markdown-preview  ">
      
<h1 id="lec1">LEC1 </h1>
<h2 id="进程和内核">进程和内核 </h2>
<p><img src="..\assets\images\s.6081\image.png" alt="alt text"><br>
这张图表明，用户所写的程序，也叫做进程process都只在用户空间中，无法直接调用CPU，内存，硬盘等；能够直接访问到硬件的称作内核kernel。所有进程都需要依靠内核提供帮助才能实现，调用内核提供的服务的调用叫做system call。</p>
<p>PID：操作系统会为每个process分配一个编号，是一个正整数。PID是唯一的，同一时刻不会有两个进程有相同的PID。</p>
<h2 id="系统调用">系统调用 </h2>
<p>下表中列出了所有的系统调用：</p>
<table>
<thead>
<tr>
<th>系统调用</th>
<th>解释</th>
</tr>
</thead>
<tbody>
<tr>
<td>fork()</td>
<td>创建一个子进程，返回子进程的PID</td>
</tr>
<tr>
<td>exit(int status)</td>
<td>终止当前进程，并把退出状态status报告给wait函数，没有返回</td>
</tr>
<tr>
<td>wait(int *status)</td>
<td>等待子进程退出，将退出状态存入*status，返回子进程PID</td>
</tr>
<tr>
<td>getpid()</td>
<td>返回当前进程PID</td>
</tr>
<tr>
<td>sleep(int n)</td>
<td>暂停n个时钟节拍</td>
</tr>
<tr>
<td>exec(char *file , char *argv[])</td>
<td>加载一个文件并使用参数执行，只有出错时返回</td>
</tr>
<tr>
<td>*sbrk(int n)</td>
<td>把进程内存增加n字节，返回新内存的开始地址</td>
</tr>
<tr>
<td>open(char *file , int flags)</td>
<td>打开文件，flag表示read/write,返回文件描述符fd</td>
</tr>
<tr>
<td>write(int fd , char *buf , int n)</td>
<td>从buf写n个字节到fd，返回n</td>
</tr>
<tr>
<td>read(int fd , char *buf , int n)</td>
<td>从fd读n个字节到buf，返回读取字节数，如果文件结束返回0</td>
</tr>
<tr>
<td>close(int fd)</td>
<td>释放fd</td>
</tr>
<tr>
<td>dup(int fd)</td>
<td>返回一个新的文件描述符，指向与fd相同的文件</td>
</tr>
<tr>
<td>pipe(int p[])</td>
<td>创建管道，把read/write文件描述符放在p[0]/p[1]中</td>
</tr>
<tr>
<td>chdir(char *dir)</td>
<td>改变当前工作目录</td>
</tr>
<tr>
<td>mkdir(char *dir)</td>
<td>创建新目录</td>
</tr>
<tr>
<td>mknod(char *file , int , int)</td>
<td>创建设备文件</td>
</tr>
<tr>
<td>fstat(int fd , struct stat *st)</td>
<td>把打开文件fd的信息放入*st</td>
</tr>
<tr>
<td>stat(char *file , struct stat *st)</td>
<td>把指定文件信息放入*st</td>
</tr>
<tr>
<td>link(char *file1 , char *file2)</td>
<td>为file1创建另一个名字file2</td>
</tr>
<tr>
<td>unlink(char *file)</td>
<td>删除文件</td>
</tr>
</tbody>
</table>
<p>接下来的内容会围绕这些system calls展开。</p>
<h2 id="fork">fork </h2>
<p><code>fork</code>会创建一个新进程，这两个进程除了PID都一样；<br>
在两个进程中，都会继续执行之后的命令，直到退出进程；<br>
只不过，在父进程中，它会得到子进程的PID作为<code>fork</code>返回值;<br>
在子进程中，它会得到0作为<code>fork</code>返回值。</p>
<p>因此，我们可以通过不同的不同的返回值进行判断得到当前处于哪个进程中。如下是一个简单的示例：</p>
<pre data-role="codeBlock" data-info="c" class="language-c c"><code><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"kernel/types.h"</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"user/user.h"</span></span>

<span class="token keyword keyword-int">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
  <span class="token keyword keyword-int">int</span> pid <span class="token operator">=</span> <span class="token function">fork</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword keyword-if">if</span><span class="token punctuation">(</span>pid <span class="token operator">&gt;</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
      <span class="token comment">// 父进程</span>

      <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"parent : child = %d \n"</span> <span class="token punctuation">,</span> pid<span class="token punctuation">)</span><span class="token punctuation">;</span>

      pid <span class="token operator">=</span> <span class="token function">wait</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token keyword keyword-int">int</span> <span class="token operator">*</span><span class="token punctuation">)</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token comment">// 不关心返回状态，因此用空指针存</span>
      <span class="token comment">// 这行代码会等到子进程结束，并返回子进程PID</span>

      <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"child %d is done\n"</span> <span class="token punctuation">,</span> pid<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span> <span class="token keyword keyword-else">else</span> <span class="token keyword keyword-if">if</span><span class="token punctuation">(</span>pid <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
      <span class="token comment">// 子进程</span>
      <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"child : existing\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token function">exit</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 退出子进程</span>
  <span class="token punctuation">}</span><span class="token keyword keyword-else">else</span><span class="token punctuation">{</span>
      <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"fork error\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
  <span class="token function">exit</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><p>输出如下：<br>
parent : child = 4<br>
child : existing<br>
child 4 is done</p>
<p>parenchitld  : chi:ld =  existin10<br>
g<br>
child 10 is done</p>
<p>可以看到，前两行很有可能混合着输出，但是child %d is done一定是放在最后的。因为父子两个进程原则上没有先后顺序，但是<code>wait</code>命令会强制等待子进程结束。</p>
<h2 id="exec">exec </h2>
<p>可以使用如下系统调用来执行可执行文件：</p>
<pre data-role="codeBlock" data-info="c" class="language-c c"><code><span class="token function">exec</span><span class="token punctuation">(</span><span class="token string">"/bin/echo"</span> <span class="token punctuation">,</span> argv<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// 第一个参数是文件目录，第二个参数是执行文件所需参数</span>
<span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"exec error\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><p>需要注意的是，使用该命令会直接用要调用的可执行文件覆盖掉当前进程的内存而不是调用新进程。这同时说明<code>exec</code>如果调用成功，其后的代码是无法执行的。</p>
<h2 id="shell">shell </h2>
<p>需要注意的是shell并不是一个系统调用，而仅仅只是一个程序。它的作用是连续地执行用户输入的指令（指向一个可执行文件）。<br>
前面我们提到过，直接使用<code>exec</code>执行指令会导致原进程被覆盖，因此每当获取到用户的输入时，shell会先<code>fork</code>，然后在子进程中调用<code>exec</code>执行用户指令。当正确的执行后，子进程会，而退出父进程会一直等到子进程退出后继续进行下一个命令的执行。<br>
可以看到具体的代码如下：</p>
<pre data-role="codeBlock" data-info="c" class="language-c c"><code><span class="token comment">// Read and run input commands.</span>
<span class="token keyword keyword-while">while</span><span class="token punctuation">(</span><span class="token function">getcmd</span><span class="token punctuation">(</span>buf<span class="token punctuation">,</span> <span class="token keyword keyword-sizeof">sizeof</span><span class="token punctuation">(</span>buf<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">&gt;=</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
  <span class="token keyword keyword-if">if</span><span class="token punctuation">(</span>buf<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token char">'c'</span> <span class="token operator">&amp;&amp;</span> buf<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token char">'d'</span> <span class="token operator">&amp;&amp;</span> buf<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token char">' '</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token comment">// Chdir must be called by the parent, not the child.</span>
    buf<span class="token punctuation">[</span><span class="token function">strlen</span><span class="token punctuation">(</span>buf<span class="token punctuation">)</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>  <span class="token comment">// chop \n</span>
    <span class="token keyword keyword-if">if</span><span class="token punctuation">(</span><span class="token function">chdir</span><span class="token punctuation">(</span>buf<span class="token operator">+</span><span class="token number">3</span><span class="token punctuation">)</span> <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span>
      <span class="token function">fprintf</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span> <span class="token string">"cannot cd %s\n"</span><span class="token punctuation">,</span> buf<span class="token operator">+</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword keyword-continue">continue</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
  <span class="token keyword keyword-if">if</span><span class="token punctuation">(</span><span class="token function">fork1</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span>
    <span class="token function">runcmd</span><span class="token punctuation">(</span><span class="token function">parsecmd</span><span class="token punctuation">(</span>buf<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">// 这里面用exec调用用户输入的指定程序</span>
  <span class="token function">wait</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><h2 id="文件描述符">文件描述符 </h2>
<p>进程总是会进行一些读、写操作，而从哪里读，写到什么地方时我们需要告诉进程的。我们有一些小整数，称作文件描述符fd来区分这些读、写的对象。<br>
按照约定，进程从文件描述符0指代的对象读取，把输出写到文件描述符1指代的对象，把错误信息写入文件描述符2指代的对象。为了简洁，后续将省略（“指代的对象”）的表述。</p>
<p>每个文件描述符fd会自动关联一个偏移量，它指代的是在fd中进行读或写操作的位置。当读出或写入n个字节后，这个偏移量会移动n以便于后续的读写操作。</p>
<p><code>read(fd , buf , n)</code>表示从fd读取n个字节并存入buf中，返回读取到的字节数n。如果没有可读字节，将会返回0。<br>
<code>write(fd , buf , n)</code>与之同理，只有在发生错误时会返回小于n的数。</p>
<p>需要注意的是，文件描述符是一个很抽象的概念，它所指代的对象不一定是文件，也可以是管道或者设备等。</p>
<h2 id="io重定向">I/O重定向 </h2>
<p>我们想从指定的地方读入和写出，比如利用某个文件中的内容作为输入:<code>cat &lt; input.txt</code>，这就需要我们能够对文件描述符所指代的对象进行调整。</p>
<p>调整的方法为对文件描述符进行打开和关闭操作。<br>
<code>close(fd)</code>表示关闭文件描述符fd，也就是说现在无法使用fd指代任何对象。<br>
<code>open("input.txt" , O_RDONLY)</code>表示把第一个参数所代表的对象与当前被关闭的最小的文件描述符对应起来，第二个参数是对这个对象进行操作的控制。</p>
<p>文件描述符0,1,2是被默认打开的，并且每一次<code>fork</code>之后，子进程会继承父进程的那些文件描述符所指代的对象。需要注意的是，fd所关联的偏移量也是被共享的。按顺序进行的父子进程（用<code>wait</code>控制）的写操作会被按顺序写到指定文件中。</p>
<p>我们可以看如下的例子：</p>
<pre data-role="codeBlock" data-info="c" class="language-c c"><code><span class="token keyword keyword-if">if</span> <span class="token punctuation">(</span><span class="token function">fork</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
  <span class="token function">close</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token function">open</span><span class="token punctuation">(</span><span class="token string">"input.txt"</span> <span class="token punctuation">,</span> O_RDONLY<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token function">exec</span><span class="token punctuation">(</span><span class="token string">"cat"</span> <span class="token punctuation">,</span> argv<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><p>该程序在子进程中把input.txt文件中的内容作为文件描述符0所指代的对象，<code>exec</code>虽然覆盖了进程的内存，但是把之前的文件表（文件描述符所指代的对象）给保存下来。这个过程中，父进程的文件描述符是不会被修改的。</p>
<p><code>open</code>指令中的控制参数有如下选择：</p>
<table>
<thead>
<tr>
<th>参数选择</th>
<th>解释</th>
</tr>
</thead>
<tbody>
<tr>
<td>O_RDONLY</td>
<td>只读</td>
</tr>
<tr>
<td>O_WRONLY</td>
<td>只写</td>
</tr>
<tr>
<td>O_RDWR</td>
<td>可读可写</td>
</tr>
<tr>
<td>O_CREATE</td>
<td>如果不存在，则创建</td>
</tr>
<tr>
<td>O_TRUNC</td>
<td>将文件截断为零长度</td>
</tr>
</tbody>
</table>
<p><code>dup(fd)</code>的含义是复制文件描述符fd给一个新的最小的可用文件描述符。比如说默认情况下，<code>dup(1)</code>会导致文件描述符3指代的内容和1是完全一样的。注意这种复制，是类似于父子进程那样，会把偏移量关联到一起，即从1进行写入，3的偏移量也会修改。</p>
<h2 id="pipe">pipe </h2>
<p>管道通过如下方式实现：</p>
<pre data-role="codeBlock" data-info="c" class="language-c c"><code><span class="token keyword keyword-int">int</span> p<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token function">pipe</span><span class="token punctuation">(</span>p<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><p>这说的是，文件描述符p[0]和p[1]同时指向一个对象，既可以从中读出数据，也可以向其中写入数据。<br>
这提供了一种跨进程传递数据的途径，管道的2个文件描述符对于后续的所有进程都是默认打开的，因此我们可以让A进程从p[0]端读出，让B进程写到p[1]端。<br>
令人疑惑的点在于，为什么需要2个端？原则上我们只需要让A进程的0指向目标对象，B进程的1指向目标对象即可。事实上直接更改进程内部文件描述符的指示确实可行，但是使用管道在执行顺序上更有优势。</p>
<p>通常而言，我们使用管道是为了把B的输出当作A的输入，因此采用以上第二种方式必须使得B进程先进行，再进行A进程。如果A、B是父子进程的关系，这将较难处理；<br>
而管道内部的传输是有阻塞机制的，即如果p[0]端发现没有可读数据，而p[1]端又没有被关闭的话，它会一直等待数据传进来。这样即使A、B是并行的两个进程，也能够保证数据的正确传输。<br>
需要注意的是，在A进程内部必须手动关掉p[1]端，因为p[1]端全部被关闭才意味着文件结束，否则无法永远读到文件的结尾。</p>
<p>一个简单的例子如下：</p>
<pre data-role="codeBlock" data-info="c" class="language-c c"><code><span class="token keyword keyword-int">int</span> p<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token keyword keyword-char">char</span> <span class="token operator">*</span>argv<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
argv<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token string">"wc"</span><span class="token punctuation">;</span>
argv<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token function">pipe</span><span class="token punctuation">(</span>p<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword keyword-if">if</span> <span class="token punctuation">(</span><span class="token function">fork</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token function">close</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token function">dup</span><span class="token punctuation">(</span>p<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token function">close</span><span class="token punctuation">(</span>p<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token function">close</span><span class="token punctuation">(</span>p<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token function">exec</span><span class="token punctuation">(</span><span class="token string">"/bin/wc"</span><span class="token punctuation">,</span> argv<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span> <span class="token keyword keyword-else">else</span> <span class="token punctuation">{</span>
  <span class="token function">close</span><span class="token punctuation">(</span>p<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token function">write</span><span class="token punctuation">(</span>p<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token string">"hello world\n"</span><span class="token punctuation">,</span> <span class="token number">12</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token function">close</span><span class="token punctuation">(</span>p<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><p>总而言之，在各个进程中，都养成关闭端口的习惯是没错的。</p>
<p>我们使用管道，是为了在shell中执行如下的命令：<code>sleep 10 | echo hi</code>。这样的结构表明，我们希望将左侧的输出当作右侧的输入结果（虽然这个例子中左侧并没有输出）。我们简要说明一下shell是如何实现这一点的。</p>
<p>shell会建立一个管道连接左右两侧，并为左右两侧都<code>fork</code>，在各自的子进程中调用需要执行的命令。这里值得注意的是，这些进程实际上是并行的，但是管道的阻塞机制能够保证数据按想要的顺序进行传输。因此如上的命令中，并不会等10秒后再打印hi，而是打印hi之后等10秒才出现下一次shell的提示。</p>
<p>上述例子只是为了解释左右两侧是并行的，更典型的例子是：<code>echo hello world | wc</code>，shell会自动把左侧的输出hello world传递给wc当作输出，尽管二者是并行的，但是管道的阻塞保证了顺序执行。</p>
<h2 id="文件系统">文件系统 </h2>
<p>可以通过<code>chdir</code>进入指定的目录：</p>
<pre data-role="codeBlock" data-info="c" class="language-c c"><code><span class="token function">chdir</span><span class="token punctuation">(</span><span class="token string">"/a"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token function">chdir</span><span class="token punctuation">(</span><span class="token string">"b"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token function">open</span><span class="token punctuation">(</span><span class="token string">"c"</span><span class="token punctuation">,</span> O_RDONLY<span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token function">open</span><span class="token punctuation">(</span><span class="token string">"/a/b/c"</span><span class="token punctuation">,</span> O_RDONLY<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// 打开的文件虽然是一样的，但是上面的代码会把当前目录带到/a/b中</span>
<span class="token comment">// 而下面的代码并不会修改当前的目录</span>
</code></pre><p><code>mkdir</code>可以创建新的目录，O_CREATE可以实现新建文件，下面是具体示例：</p>
<pre data-role="codeBlock" data-info="c" class="language-c c"><code><span class="token function">mkdir</span><span class="token punctuation">(</span><span class="token string">"/dir"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
fd <span class="token operator">=</span> <span class="token function">open</span><span class="token punctuation">(</span><span class="token string">"/dir/file"</span><span class="token punctuation">,</span> O_CREATE <span class="token operator">|</span> O_WRONLY<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><p><code>mknod</code>新建一个设备文件；之前的文件是存储下来的数据，而设备文件可以理解成访问硬件设备的接口，我们可以通过调用它来得到诸如键盘输入的信息（并非是存储下来的数据）。</p>
<pre data-role="codeBlock" data-info="c" class="language-c c"><code><span class="token function">mknod</span><span class="token punctuation">(</span><span class="token string">"/console"</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><p>第一个参数是文件的目录，第二、三个参数是主次设备编号，可以通过这两个数唯一确定一个硬件设备。</p>
<p>一个文件可以拥有很多名字，这些底层的文件称作inode，而各种名字称作link。每个inode中会存储如下信息：</p>
<pre data-role="codeBlock" data-info="c" class="language-c c"><code><span class="token keyword keyword-struct">struct</span> <span class="token class-name">stat</span> <span class="token punctuation">{</span>
  <span class="token keyword keyword-int">int</span> dev<span class="token punctuation">;</span>     <span class="token comment">// 文件系统的磁盘设备</span>
  uint ino<span class="token punctuation">;</span>    <span class="token comment">// Inode编号</span>
  <span class="token keyword keyword-short">short</span> type<span class="token punctuation">;</span>  <span class="token comment">// 文件类型</span>
  <span class="token keyword keyword-short">short</span> nlink<span class="token punctuation">;</span> <span class="token comment">// 指向文件的链接数</span>
  uint64 size<span class="token punctuation">;</span> <span class="token comment">// 文件字节数</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre><p>进行如下指令，将得到nlink=2：</p>
<pre data-role="codeBlock" data-info="c" class="language-c c"><code><span class="token function">open</span><span class="token punctuation">(</span><span class="token string">"a"</span><span class="token punctuation">,</span> O_CREATE <span class="token operator">|</span> O_WRONLY<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token function">link</span><span class="token punctuation">(</span><span class="token string">"a"</span><span class="token punctuation">,</span> <span class="token string">"b"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><p>使用<code>unlink</code>可以删除名称，但是把所有名称都删完并不会直接把磁盘上存储inode的空间全部释放，只有满足没有文件描述符指代的对象是这个inode时，空间才会被释放。如下程序实现了创建临时inode（未命名），它会在fd被关闭之后自动释放内存：</p>
<pre data-role="codeBlock" data-info="c" class="language-c c"><code>fd <span class="token operator">=</span> <span class="token function">open</span><span class="token punctuation">(</span><span class="token string">"/tmp/xyz"</span><span class="token punctuation">,</span> O_CREATE <span class="token operator">|</span> O_RDWR<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token function">unlink</span><span class="token punctuation">(</span><span class="token string">"/tmp/xyz"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><h2 id="lab1--xv6-and-unix-utilities">Lab1 : Xv6 and Unix utilities </h2>
<p>环境搭建提醒：<br>
安装虚拟机ubuntu 20.04(不要用24.04，否则后续会出错)；<br>
其余步骤按照官方提示即可。</p>
<p>点击可以展开各个实验的具体代码实现:</p>
<details>
<summary>sleep</summary>
<pre data-role="codeBlock" data-info="c" class="language-c c"><code><span class="token comment">// sleep.c</span>

<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"kernel/types.h"</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"user/user.h"</span></span>

<span class="token keyword keyword-int">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword keyword-int">int</span> argc <span class="token punctuation">,</span> <span class="token keyword keyword-char">char</span> <span class="token operator">*</span>argv<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
  <span class="token keyword keyword-if">if</span><span class="token punctuation">(</span>argc <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
      <span class="token function">fprintf</span><span class="token punctuation">(</span><span class="token number">2</span> <span class="token punctuation">,</span> <span class="token string">"Error : No argument!"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token function">exit</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>

  <span class="token function">sleep</span><span class="token punctuation">(</span><span class="token function">atoi</span><span class="token punctuation">(</span>argv<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token function">exit</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></details>
<details>
<summary>pingpong</summary>
<pre data-role="codeBlock" data-info="c" class="language-c c"><code><span class="token comment">// pingpong.c</span>

<span class="token macro property"><span class="token directive-hash">#</span> <span class="token directive keyword">include</span><span class="token string">"kernel/types.h"</span></span>
<span class="token macro property"><span class="token directive-hash">#</span> <span class="token directive keyword">include</span><span class="token string">"user/user.h"</span></span>

<span class="token keyword keyword-int">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
  <span class="token comment">// parent -&gt; child p1</span>
  <span class="token comment">// child -&gt; parent p2</span>
  <span class="token keyword keyword-int">int</span> p1<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span> <span class="token punctuation">,</span> p2<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
  <span class="token function">pipe</span><span class="token punctuation">(</span>p1<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token function">pipe</span><span class="token punctuation">(</span>p2<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword keyword-if">if</span><span class="token punctuation">(</span><span class="token function">fork</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
      <span class="token comment">// child process</span>
      <span class="token keyword keyword-int">int</span> pid <span class="token operator">=</span> <span class="token function">getpid</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token keyword keyword-char">char</span> buf<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
      <span class="token function">close</span><span class="token punctuation">(</span>p1<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token function">close</span><span class="token punctuation">(</span>p2<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

      <span class="token function">read</span><span class="token punctuation">(</span>p1<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token punctuation">,</span> buf <span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token function">close</span><span class="token punctuation">(</span>p1<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

      <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d: received ping\n"</span> <span class="token punctuation">,</span> pid<span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token comment">// 注意: 后有一个空格</span>

      <span class="token function">write</span><span class="token punctuation">(</span>p2<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token punctuation">,</span> <span class="token string">" "</span> <span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token function">close</span><span class="token punctuation">(</span>p2<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token function">exit</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span><span class="token keyword keyword-else">else</span><span class="token punctuation">{</span>
      <span class="token comment">// parent process</span>
      <span class="token keyword keyword-int">int</span> pid <span class="token operator">=</span> <span class="token function">getpid</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token keyword keyword-char">char</span> buf<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>

      <span class="token function">close</span><span class="token punctuation">(</span>p1<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token function">write</span><span class="token punctuation">(</span>p1<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token punctuation">,</span> <span class="token string">" "</span> <span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token function">close</span><span class="token punctuation">(</span>p1<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

      <span class="token function">close</span><span class="token punctuation">(</span>p2<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token function">read</span><span class="token punctuation">(</span>p2<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token punctuation">,</span> buf <span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token function">close</span><span class="token punctuation">(</span>p2<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d: received pong\n"</span> <span class="token punctuation">,</span> pid<span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token function">exit</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></details>
<details>
<summary>primes</summary>
<pre data-role="codeBlock" data-info="c" class="language-c c"><code><span class="token comment">// primes.c</span>
<span class="token macro property"><span class="token directive-hash">#</span> <span class="token directive keyword">include</span><span class="token string">"kernel/types.h"</span></span>
<span class="token macro property"><span class="token directive-hash">#</span> <span class="token directive keyword">include</span><span class="token string">"user/user.h"</span></span>

<span class="token keyword keyword-void">void</span> <span class="token function">next</span><span class="token punctuation">(</span><span class="token keyword keyword-int">int</span> p<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
  <span class="token keyword keyword-int">int</span> pp<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
  <span class="token function">pipe</span><span class="token punctuation">(</span>pp<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token comment">//  从p读出第一个数，并输出；如果读不出来，则返回</span>
  <span class="token keyword keyword-int">int</span> out<span class="token punctuation">;</span>
  <span class="token function">close</span><span class="token punctuation">(</span>p<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword keyword-if">if</span><span class="token punctuation">(</span><span class="token function">read</span><span class="token punctuation">(</span>p<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token punctuation">,</span> <span class="token operator">&amp;</span>out <span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
      <span class="token function">close</span><span class="token punctuation">(</span>p<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token function">exit</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
  <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"prime %d\n"</span> <span class="token punctuation">,</span> out<span class="token punctuation">)</span><span class="token punctuation">;</span>

  <span class="token keyword keyword-if">if</span><span class="token punctuation">(</span><span class="token function">fork</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
      <span class="token comment">// 子进程，跳到下一个next(pp)</span>
      <span class="token function">close</span><span class="token punctuation">(</span>p<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token function">next</span><span class="token punctuation">(</span>pp<span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token function">exit</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span><span class="token keyword keyword-else">else</span><span class="token punctuation">{</span>
      <span class="token comment">// 父进程，继续读出之后的数，并筛选，写到管道pp之中</span>
      <span class="token function">close</span><span class="token punctuation">(</span>pp<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 在写之前要先关掉，否则下一步读取会出问题</span>
      <span class="token keyword keyword-int">int</span> x<span class="token punctuation">;</span>
      <span class="token keyword keyword-while">while</span><span class="token punctuation">(</span><span class="token function">read</span><span class="token punctuation">(</span>p<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token punctuation">,</span> <span class="token operator">&amp;</span>x <span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
          <span class="token keyword keyword-if">if</span><span class="token punctuation">(</span><span class="token punctuation">(</span>x <span class="token operator">%</span> out<span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
              <span class="token function">write</span><span class="token punctuation">(</span>pp<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token punctuation">,</span> <span class="token operator">&amp;</span>x <span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
          <span class="token punctuation">}</span>
      <span class="token punctuation">}</span>
      <span class="token function">close</span><span class="token punctuation">(</span>p<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token function">close</span><span class="token punctuation">(</span>pp<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token function">wait</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 养成好习惯，等待子进程返回，否则会形成僵尸进程</span>
      <span class="token comment">// 同时也有清理资源的效果</span>
      <span class="token function">exit</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword keyword-int">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
  <span class="token comment">// 设计想法：要实现进程套进程，需要用函数递归实现</span>
  <span class="token comment">// 父子两个进程，子进程调用函数自身，父进程进行处理</span>
  <span class="token comment">// 这样实际的有效进程就是那些父进程</span>
  
  <span class="token keyword keyword-int">int</span> a<span class="token punctuation">[</span><span class="token number">40</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
  <span class="token keyword keyword-int">int</span> p<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
  <span class="token function">pipe</span><span class="token punctuation">(</span>p<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword keyword-for">for</span><span class="token punctuation">(</span><span class="token keyword keyword-int">int</span> i <span class="token operator">=</span> <span class="token number">2</span> <span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> <span class="token number">35</span> <span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
      a<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">2</span><span class="token punctuation">]</span> <span class="token operator">=</span> i<span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
  <span class="token function">write</span><span class="token punctuation">(</span>p<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token punctuation">,</span> a <span class="token punctuation">,</span> <span class="token number">34</span> <span class="token operator">*</span> <span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

  <span class="token function">next</span><span class="token punctuation">(</span>p<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token function">exit</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></details>
<details>
<summary>find</summary>
<pre data-role="codeBlock" data-info="c" class="language-c c"><code><span class="token comment">// find.c</span>

<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"kernel/types.h"</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"kernel/stat.h"</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"user/user.h"</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"kernel/fs.h"</span></span>

<span class="token keyword keyword-void">void</span> <span class="token function">find</span><span class="token punctuation">(</span><span class="token keyword keyword-char">char</span> <span class="token operator">*</span>path <span class="token punctuation">,</span> <span class="token keyword keyword-char">char</span> <span class="token operator">*</span>s<span class="token punctuation">)</span><span class="token punctuation">{</span>
  <span class="token keyword keyword-char">char</span> buf<span class="token punctuation">[</span><span class="token number">512</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token operator">*</span>p<span class="token punctuation">;</span>
  <span class="token keyword keyword-int">int</span> fd<span class="token punctuation">;</span>
  <span class="token keyword keyword-struct">struct</span> <span class="token class-name">dirent</span> de<span class="token punctuation">;</span>
  <span class="token keyword keyword-struct">struct</span> <span class="token class-name">stat</span> st<span class="token punctuation">;</span>

  fd <span class="token operator">=</span> <span class="token function">open</span><span class="token punctuation">(</span>path <span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token function">fstat</span><span class="token punctuation">(</span>fd <span class="token punctuation">,</span> <span class="token operator">&amp;</span>st<span class="token punctuation">)</span><span class="token punctuation">;</span>

  <span class="token keyword keyword-if">if</span><span class="token punctuation">(</span>st<span class="token punctuation">.</span>type <span class="token operator">==</span> T_DIR<span class="token punctuation">)</span><span class="token punctuation">{</span>
      <span class="token comment">// 如果当前是目录</span>
      <span class="token comment">// 获取其中合法的地址，递归调用即可</span>
      <span class="token function">strcpy</span><span class="token punctuation">(</span>buf<span class="token punctuation">,</span> path<span class="token punctuation">)</span><span class="token punctuation">;</span>
      p <span class="token operator">=</span> buf<span class="token operator">+</span><span class="token function">strlen</span><span class="token punctuation">(</span>buf<span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token operator">*</span>p<span class="token operator">++</span> <span class="token operator">=</span> <span class="token char">'/'</span><span class="token punctuation">;</span>
      <span class="token comment">// 先添加/，p始终指向/后的位置，枚举其子文件</span>

      <span class="token keyword keyword-while">while</span><span class="token punctuation">(</span><span class="token function">read</span><span class="token punctuation">(</span>fd<span class="token punctuation">,</span> <span class="token operator">&amp;</span>de<span class="token punctuation">,</span> <span class="token keyword keyword-sizeof">sizeof</span><span class="token punctuation">(</span>de<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token keyword keyword-sizeof">sizeof</span><span class="token punctuation">(</span>de<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
          
          <span class="token comment">// 跳过当前目录和父母录以及无效目录，避免无穷递归</span>
          <span class="token keyword keyword-if">if</span><span class="token punctuation">(</span>de<span class="token punctuation">.</span>inum <span class="token operator">==</span> <span class="token number">0</span> <span class="token operator">||</span> <span class="token function">strcmp</span><span class="token punctuation">(</span>de<span class="token punctuation">.</span>name <span class="token punctuation">,</span> <span class="token string">"."</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span> <span class="token operator">||</span> <span class="token function">strcmp</span><span class="token punctuation">(</span>de<span class="token punctuation">.</span>name <span class="token punctuation">,</span> <span class="token string">".."</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span>
              <span class="token keyword keyword-continue">continue</span><span class="token punctuation">;</span>

          <span class="token comment">// 把de.name复制到指针p所指位置之后</span>
          <span class="token function">memmove</span><span class="token punctuation">(</span>p<span class="token punctuation">,</span> de<span class="token punctuation">.</span>name<span class="token punctuation">,</span> DIRSIZ<span class="token punctuation">)</span><span class="token punctuation">;</span>
          p<span class="token punctuation">[</span>DIRSIZ<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token comment">// 确保buf中路径正确结束</span>

          <span class="token comment">// 检查路径是否有效</span>
          <span class="token keyword keyword-if">if</span><span class="token punctuation">(</span><span class="token function">stat</span><span class="token punctuation">(</span>buf<span class="token punctuation">,</span> <span class="token operator">&amp;</span>st<span class="token punctuation">)</span> <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span> 
              <span class="token keyword keyword-continue">continue</span><span class="token punctuation">;</span>
          
          <span class="token comment">// 放在这里判断，可以直接调用de.name获取名字</span>
          <span class="token comment">// 如果直接在文件处进行判断的话，还需要获取路径末尾的名字</span>
          <span class="token keyword keyword-if">if</span><span class="token punctuation">(</span>st<span class="token punctuation">.</span>type <span class="token operator">==</span> T_DIR<span class="token punctuation">)</span>
              <span class="token function">find</span><span class="token punctuation">(</span>buf <span class="token punctuation">,</span> s<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 确保传入的是目录，下一次的open才能打开</span>
          <span class="token keyword keyword-else">else</span> <span class="token keyword keyword-if">if</span><span class="token punctuation">(</span>st<span class="token punctuation">.</span>type <span class="token operator">==</span> T_FILE<span class="token punctuation">)</span><span class="token punctuation">{</span>
              <span class="token keyword keyword-if">if</span><span class="token punctuation">(</span><span class="token function">strcmp</span><span class="token punctuation">(</span>s <span class="token punctuation">,</span> de<span class="token punctuation">.</span>name<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span>
                  <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%s\n"</span> <span class="token punctuation">,</span> buf<span class="token punctuation">)</span><span class="token punctuation">;</span>
          <span class="token punctuation">}</span>
      <span class="token punctuation">}</span>       
  <span class="token punctuation">}</span>
  <span class="token function">close</span><span class="token punctuation">(</span>fd<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword keyword-return">return</span> <span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword keyword-int">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword keyword-int">int</span> argc <span class="token punctuation">,</span> <span class="token keyword keyword-char">char</span> <span class="token operator">*</span>argv<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
  
  <span class="token function">find</span><span class="token punctuation">(</span>argv<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token punctuation">,</span> argv<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token function">exit</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></details>
<details>
<summary>xargs</summary>
<pre data-role="codeBlock" data-info="c" class="language-c c"><code><span class="token comment">// xargs.c</span>

<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"kernel/types.h"</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"user/user.h"</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"kernel/param.h"</span></span>

<span class="token keyword keyword-int">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword keyword-int">int</span> argc <span class="token punctuation">,</span> <span class="token keyword keyword-char">char</span> <span class="token operator">*</span>argv<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
  
  <span class="token keyword keyword-char">char</span> <span class="token operator">*</span>new_argv<span class="token punctuation">[</span>MAXARG<span class="token punctuation">]</span><span class="token punctuation">;</span>
  <span class="token keyword keyword-char">char</span> c<span class="token punctuation">;</span>
  <span class="token keyword keyword-char">char</span> buf<span class="token punctuation">[</span><span class="token number">512</span><span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment">// 用来存储输入的参数</span>
  <span class="token keyword keyword-int">int</span> n <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>

  <span class="token comment">// argv[0]指的是xargs , argv[1]才是我们要调用的程序</span>

  <span class="token keyword keyword-for">for</span><span class="token punctuation">(</span><span class="token keyword keyword-int">int</span> i <span class="token operator">=</span> <span class="token number">1</span> <span class="token punctuation">;</span> i <span class="token operator">&lt;</span> argc <span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
      new_argv<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> argv<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>

  <span class="token keyword keyword-while">while</span><span class="token punctuation">(</span><span class="token function">read</span><span class="token punctuation">(</span><span class="token number">0</span> <span class="token punctuation">,</span> <span class="token operator">&amp;</span>c <span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
      <span class="token keyword keyword-if">if</span><span class="token punctuation">(</span>c <span class="token operator">==</span> <span class="token char">'\n'</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
          <span class="token comment">// 确保字符串正确结束</span>
          buf<span class="token punctuation">[</span>n<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token char">'\0'</span><span class="token punctuation">;</span>
          
          <span class="token keyword keyword-if">if</span><span class="token punctuation">(</span>n <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span>
              new_argv<span class="token punctuation">[</span>argc <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
          <span class="token keyword keyword-else">else</span><span class="token punctuation">{</span>
              new_argv<span class="token punctuation">[</span>argc <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> buf<span class="token punctuation">;</span>
              new_argv<span class="token punctuation">[</span>argc<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
          <span class="token punctuation">}</span>

          <span class="token keyword keyword-if">if</span><span class="token punctuation">(</span><span class="token function">fork</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
              <span class="token function">exec</span><span class="token punctuation">(</span>new_argv<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token punctuation">,</span> new_argv<span class="token punctuation">)</span><span class="token punctuation">;</span>
              new_argv<span class="token punctuation">[</span>argc <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
              new_argv<span class="token punctuation">[</span>argc<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
              <span class="token function">exit</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
          <span class="token punctuation">}</span>
          <span class="token keyword keyword-else">else</span><span class="token punctuation">{</span>
              <span class="token function">wait</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
              new_argv<span class="token punctuation">[</span>argc <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
              new_argv<span class="token punctuation">[</span>argc<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
          <span class="token punctuation">}</span>
          n <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
      <span class="token punctuation">}</span>
      <span class="token keyword keyword-else">else</span><span class="token punctuation">{</span>
          <span class="token comment">// 注意不要把换行符读进buf里</span>
          buf<span class="token punctuation">[</span>n<span class="token punctuation">]</span> <span class="token operator">=</span> c<span class="token punctuation">;</span>
          n<span class="token operator">++</span><span class="token punctuation">;</span>
      <span class="token punctuation">}</span>
      
  <span class="token punctuation">}</span>

  <span class="token function">exit</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></details>
<h1 id="lec2">LEC2 </h1>
<h2 id="内存">内存 </h2>
<p>C语言中内存：<br>
<strong>静态内存</strong><br>
全局变量，随时可以访问；<br>
使用static定义，或者在全局作用域中定义。<br>
<strong>栈内存</strong><br>
函数内部的局部变量，函数退出后销毁。<br>
<strong>堆内存</strong><br>
使用<code>malloc</code>和<code>free</code>创建和销毁；<br>
可能导致内存泄漏，释放后使用。</p>
<h2 id="可变对象与不可变对象">可变对象与不可变对象 </h2>
<p>在python中，赋值操作（<code>a=b</code>）并不会为a创建新的对象，而是让不同的变量名a,b指向同一个对象。<br>
当对于变量a进行修改时，可变对象（列表、字典、集合）和不可变对象（整数、字符串、元组）的修改方式是不同的：<br>
可变对象会直接修改变量名a所对应的那个对象，因此不同变量名指向同一对象的话都会被修改掉；<br>
不可变对象会为变量a创建一个新的对象，再进行修改。<br>
可以参考如下示例：</p>
<pre data-role="codeBlock" data-info="python" class="language-python python"><code>a <span class="token operator">=</span> <span class="token number">1</span>
b <span class="token operator">=</span> a
b <span class="token operator">+=</span> <span class="token number">1</span> <span class="token comment"># 创建新对象</span>
<span class="token comment"># 此时a = 1 , b = 2</span>

abc <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token string">'a'</span> <span class="token punctuation">,</span> <span class="token string">'b'</span> <span class="token punctuation">,</span> <span class="token string">'c'</span><span class="token punctuation">]</span>
abcdef <span class="token operator">=</span> abc
abcdef <span class="token operator">+=</span> <span class="token punctuation">[</span><span class="token string">'d'</span> <span class="token punctuation">,</span> <span class="token string">'e'</span> <span class="token punctuation">,</span> <span class="token string">'f'</span><span class="token punctuation">]</span> <span class="token comment"># 不创建新对象</span>
<span class="token comment"># 此时abc = ['a' , 'b' , 'c' , 'd' , 'e' , 'f']</span>
<span class="token comment"># abcdef = ['a' , 'b' , 'c' , 'd' , 'e' , 'f']</span>
</code></pre><h2 id="指针">指针 </h2>
<p>指针：内存的地址，是一个64位数字，也就是8字节；</p>
<p>指针也有指针，我们可以通过修改二级指针（指针的地址）来修改该指针的指向，而不是该指针所指向的值。</p>
<p>指针的运算并不是简单的数学运算，而是按照所指向的数据类型进行移动：</p>
<pre data-role="codeBlock" data-info="c" class="language-c c"><code><span class="token keyword keyword-int">int</span> <span class="token operator">*</span>p <span class="token punctuation">;</span> 
p <span class="token operator">+=</span> <span class="token number">1</span><span class="token punctuation">;</span> <span class="token comment">// 地址加4，指向下一个整数</span>
</code></pre><p>指针的一些具体应用解释如下：</p>
<pre data-role="codeBlock" data-info="c" class="language-c c"><code><span class="token keyword keyword-int">int</span> x <span class="token operator">=</span> <span class="token number">5</span><span class="token punctuation">;</span>

<span class="token keyword keyword-int">int</span> <span class="token operator">*</span>x_addr <span class="token operator">=</span> <span class="token operator">&amp;</span>x<span class="token punctuation">;</span>
<span class="token keyword keyword-int">int</span><span class="token operator">*</span> x_addr <span class="token operator">=</span> <span class="token operator">&amp;</span>x<span class="token punctuation">;</span>
<span class="token comment">// 以上两个操作是完全一样的，都是声明指向int的指针</span>

<span class="token operator">*</span>x_addr <span class="token operator">=</span> <span class="token number">6</span><span class="token punctuation">;</span>
<span class="token comment">// * 可以通过指针访问到它指向的内存的值</span>

<span class="token keyword keyword-int">int</span> arr<span class="token punctuation">[</span><span class="token number">10</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token comment">// 默认数组名arr代表指向数组第一个元素的指针</span>

<span class="token keyword keyword-int">int</span> <span class="token operator">*</span>arr2<span class="token punctuation">[</span><span class="token number">10</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token comment">// 指针数组，每一个元素都是指针</span>
<span class="token comment">// arr2是指向这些指针的指针</span>

<span class="token keyword keyword-void">void</span> <span class="token operator">*</span>myptr<span class="token punctuation">;</span>
<span class="token comment">// 通用类型指针，可以指向任意类型的数据</span>
<span class="token punctuation">(</span><span class="token keyword keyword-char">char</span><span class="token operator">*</span><span class="token punctuation">)</span> myptr <span class="token operator">&lt;</span> end<span class="token punctuation">;</span>
<span class="token comment">// 转化成char类型指针进行检查</span>

arr<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">50</span><span class="token punctuation">;</span>
<span class="token number">2</span><span class="token punctuation">[</span>arr<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">50</span><span class="token punctuation">;</span>
<span class="token operator">*</span><span class="token punctuation">(</span>arr <span class="token operator">+</span> <span class="token number">2</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token number">50</span><span class="token punctuation">;</span>
<span class="token comment">// 这三行代码是等价的</span>
<span class="token comment">// 因为arr[2]会被编译器解释为*(arr + 2)</span>
<span class="token comment">// 而加法满足交换律，因此这和2[arr]在编译器看来是完全一样的</span>
</code></pre><p><strong>提醒</strong>：C语言不会对数组越界进行检查，因此应该主动用变量记录数组大小，在访问时手动检查索引是否越界。</p>
<h2 id="include">#include </h2>
<p>.h：头文件，声明，告诉编译器有什么，但不具体实现<br>
.c: 源文件，负责实现，完成功能。</p>
<p>#include：不要包含.c文件！</p>
<p><code>extern</code>关键字：<br>
比如在a.c中定义了函数foo();<br>
在b.c中可以使用extern int foo();<br>
声明后可以直接在b.c中调用foo()。<br>
具体来说，编译器遇到extern时会知道foo()不在这个文件中，会把foo()标记成未定义符号，但是仍然能够生成可编译的b.o。在链接阶段，链接器会扫描到b.o的未定义的符号foo()并和a.o中的已定义的foo()进行匹配，把b.o中对foo()的调用定位到a.o中foo()的实际内存地址。<br>
所以说编译器只做了声明检查，连接地址是通过链接器实现的。</p>
<h2 id="gdb调试">gdb调试 </h2>
<table>
<thead>
<tr>
<th>命令</th>
<th>解释</th>
</tr>
</thead>
<tbody>
<tr>
<td>gdb [name]</td>
<td>启动对name的调试</td>
</tr>
<tr>
<td>break/b [location]</td>
<td>在某一行、地址、函数名处设置断点</td>
</tr>
<tr>
<td>delete [number]</td>
<td>删除断点</td>
</tr>
<tr>
<td>disable [number]</td>
<td>暂时禁用断点</td>
</tr>
<tr>
<td>enable [number]</td>
<td>重新启用断点</td>
</tr>
<tr>
<td>step/s</td>
<td>执行下一行代码，会进入函数内部</td>
</tr>
<tr>
<td>next</td>
<td>执行下一行代码，跳过整个函数，停在函数返回后下一行</td>
</tr>
<tr>
<td>stepi</td>
<td>执行下一条汇编代码，进入函数</td>
</tr>
<tr>
<td>nexti</td>
<td>执行下一条汇编指令，跳过函数</td>
</tr>
<tr>
<td>continue/c</td>
<td>从当前位置运行到下一个断点</td>
</tr>
<tr>
<td>finish</td>
<td>运行到当前函数执行完毕，并返回到调用者处</td>
</tr>
<tr>
<td>advance [location]</td>
<td>继续运行到某个位置</td>
</tr>
<tr>
<td>break [location] if [condition]</td>
<td>满足条件时触发断点</td>
</tr>
<tr>
<td>cond [number] [condition]</td>
<td>给已有断点添加条件</td>
</tr>
<tr>
<td>watch [expression]</td>
<td>在表达式的值发生改变时停止</td>
</tr>
<tr>
<td>watch -l [address]</td>
<td>内容发生变化时停止</td>
</tr>
<tr>
<td>rwatch [expression]</td>
<td>[expression]被读取时停止</td>
</tr>
<tr>
<td>x/d(x,s,i) [expression]</td>
<td>十进制（十六进制、字符串、汇编）展示表达式</td>
</tr>
<tr>
<td>print/p [expression]</td>
<td>计算一个c语言表达式</td>
</tr>
<tr>
<td>backtrace/bt</td>
<td>打印函数调用栈</td>
</tr>
<tr>
<td>list [location]</td>
<td>打印源码</td>
</tr>
<tr>
<td>layout [name]</td>
<td>切换指定布局</td>
</tr>
<tr>
<td>set [expression]</td>
<td>直接修改变量的值</td>
</tr>
</tbody>
</table>
<h1 id="lec3">LEC3 </h1>
<h2 id="模式管理">模式管理 </h2>
<p>为了实现进程隔离，RISC-V有三种CPU执行模式：<br>
机器模式（Machine Mode）：主要用于配置计算机；</p>
<p>管理模式（Supervisor Mode）：执行特权指令（包括启用、禁用、读取、写入寄存器等，system call），也就是之前所说的在内核空间中运行。</p>
<p>用户模式（User Mode）：应用程序执行指令的位置，也就是之前所说的用户控件运行。通过CPU的特殊指令可以从用户模式切换到管理模式，在内核指定入口进入内核（RISC-V中提供<code>escall</code>指令）。</p>
<h2 id="内核组织">内核组织 </h2>
<p>宏内核（Monolithic Kernel）：操作系统都在内核中，所有system call都以管理模式运行，不必考虑哪一部分不需要完全的硬件特权。<br>
宏内核的缺点是，所有操作系统的子系统都被封在内核中，它们之间的互相调用很复杂。并且一旦出错的话，整个内核都运行不了，计算机就会停止工作。</p>
<p>微内核（Microkernel）：最大限度减少管理模式下运行的操作系统代码量，并在用户模式下执行大部分操作系统，如下图所示，应用程序shell通过向同样处在用户空间的文件系统发送消息实现文件的读写：<br>
<img src="..\assets\images\s.6081\image-1.png" alt="alt text"></p>
<p>大多数操作系统是用宏内核实现的，包括Unix,以及课程实验中的xv6。</p>
<h2 id="进程">进程 </h2>
<p>进程：隔离的单元，不能访问其他进程的内存、CPU、文件描述符，不能破坏内核。<br>
进程给程序一种错觉，即它有自己的地址空间（其他进程不能用这个地址空间），也有自己的CPU来执行命令。</p>
<p>进程的地址空间分配如下：<br>
<img src="..\assets\images\s.6081\image-2.png" alt="alt text"><br>
user text and data:存放用户程序的可执行指令和全局变量；<br>
user stack：用户栈，调用函数时存放局部变量、返回地址等临时消息；<br>
heap：存放运行时动态申请的内存；<br>
trapframe：陷阱帧，保存进程进入内核时的上下文；<br>
tramponline：跳板，实现用户态和内核态之间的切换。</p>
<p>页表（pagetable）：<br>
每个进程都有一个页表，用于进程的虚拟地址空间和实际物理地址之间的映射。<br>
页表由硬件实现，查找虚拟地址时只使用低39位，xv6只使用其中的38位，因此最大地址MAXVA=<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mn>2</mn><mn>38</mn></msup><mo>−</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">2^{38}-1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8974em;vertical-align:-0.0833em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">38</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">1</span></span></span></span>。</p>
<p>内核栈：<br>
进程因为系统调用进入内核执行代码，执行代码需要用到内核栈。<br>
内核栈位于内核地址空间，与用户空间隔离。<br>
每个进程都有自己对应的内核栈。</p>
<p>进程状态：<br>
未分配；<br>
已就绪，但是还未被执行；<br>
被阻塞，正在等待某个事件，比如之前提到的子进程等待管道中信息传输；<br>
正在执行；<br>
已退出，正在等待父进程回收资源。</p>
<p>proc结构体：用来维护进程的所有信息。<br>
p-&gt;pagetable:指向该进程页表的指针；<br>
p-&gt;kstack：指向该进程内核栈的指针；<br>
p-&gt;state：表示该进程处于什么状态。</p>
<p>线程：执行进程的实体（打工人）。</p>
<p>系统调用与模式切换：<br>
用户程序通过<code>ecall</code>指令发起系统调用；<br>
换到管理模式，并把程序计数器（PC）切换到内核入口；<br>
线程开始用内核栈来处理要执行的内核函数；<br>
内核代码通过<code>sret</code>指令回到用户模式，线程开始恢复使用用户栈执行指令。</p>
<p>思考：为什么要给每个进程绑定一个内核栈？<br>
原则上，进程可能都不会使用内核，但是我们依然在创建进程时就为其在内核空间中分配了内核栈，而不是等到进程进入内核之后再为其创建；<br>
这主要是因为进程是并行的，可能有多个进程正在运行或者阻塞，如果有共用内核栈将会导致执行错误，因此这么做可以彻底把进程隔离开；<br>
进程可能被阻塞在内核中，等其他信息传入；等进程被唤醒时，必须用属于这个进程的那些状态信息，因此内核栈应该为每个进程独立保存。</p>
<h2 id="启动xv6">启动xv6 </h2>
<p>我们描述一下在RISC-V计算机上启动xv6的过程：</p>
<p>RISC-V上电，初始化，运行一个存储在只读内存中的引导加载程序（Boatloader）；<br>
引导加载程序把xv6内核加载到物理地址0x80000000起始的内存中（这是因为0x0:0x80000000之间存放的是I/O设备）；</p>
<p>进入机器模式，CPU从汇编程序<code>entry.S</code>开始运行xv6；<br>
<code>_entry</code>声明了一个栈区，因此可以开始运行C代码<code>start</code>;<br>
<code>start</code>执行一些仅在机器模式下的配置后，通过RISC-V提供的<code>mret</code>指令切换到管理模式；<br>
<code>start</code>在完成切换到管理模式前，会把PC的值改为<code>main</code>函数地址，因此下一步会直接进入到<code>main</code>函数中；</p>
<p><code>main</code>函数先初始化几个设备和子系统；<br>
然后调用<code>userinit</code>创建第一个进程；<br>
这个进程执行<code>initcode.S</code>的汇编程序；<br>
这个汇编程序调用了system call<code>exec</code>执行程序文件<code>init</code>；<br>
正如我们之前所解释的那样，<code>exec</code>会用新的进程覆盖掉之前的进程，因此该进程会进入用户空间而非内核空间，因为<code>init</code>是保存在用户空间中的；</p>
<p><code>init</code>会创建一个新的控制台设备文件，并将其作为标准输入、输出和错误（即文件描述符0,1,2对应的对象）；<br>
<code>init</code>随后调用<code>sh</code>来启动shell，它继承了之前定义的文件描述符，因此会把控制台设备文件当作标准输入，输出和错误；<br>
xv6系统完成启动。</p>
<p>用户空间的程序在user目录中，内核空间的程序在kernel目录中。</p>
<p>思考：这里面的<code>init</code>,<code>sh</code>都是定义在user目录中的，为什么还说xv6是宏内核的呢？<br>
这些其实都只是应用程序，并不是操作系统的核心服务；<br>
操作系统的核心服务包括：进程调度，内存管理，文件系统等，这些核心部件是写在kernel中的。</p>
<h2 id="lab2--system-calls">Lab2 : system calls </h2>
<p>点击可以展开各个实验的具体代码实现:</p>
<details>
<summary>trace</summary>
<p>在user/user.h中添加：</p>
<pre data-role="codeBlock" data-info="c" class="language-c c"><code><span class="token comment">// system calls</span>
<span class="token keyword keyword-int">int</span> <span class="token function">trace</span><span class="token punctuation">(</span><span class="token keyword keyword-int">int</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><p>在user/usys.pl中添加：</p>
<pre data-role="codeBlock" data-info="pl" class="language-pl pl"><code>entry("trace");
</code></pre><p>在kernel/syscall.h中添加：</p>
<pre data-role="codeBlock" data-info="c" class="language-c c"><code><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">SYS_trace</span>  <span class="token expression"><span class="token number">22</span></span></span>
</code></pre><p>在kernel/proc.h的<code>proc</code>结构体中新增：</p>
<pre data-role="codeBlock" data-info="c" class="language-c c"><code><span class="token keyword keyword-int">int</span> trace_mask<span class="token punctuation">;</span>              <span class="token comment">// 需要被跟踪的系统调用掩码</span>
</code></pre><p>在kernel/sysproc.c中添加：</p>
<pre data-role="codeBlock" data-info="c" class="language-c c"><code>uint64
<span class="token function">sys_trace</span><span class="token punctuation">(</span><span class="token keyword keyword-void">void</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
<span class="token comment">// 从用户空间获取trace_mask,并保存到proc结构体中</span>

<span class="token keyword keyword-int">int</span> mask<span class="token punctuation">;</span>
<span class="token comment">// 0的意思是获取的是系统调用参数的索引</span>
<span class="token keyword keyword-if">if</span><span class="token punctuation">(</span><span class="token function">argint</span><span class="token punctuation">(</span><span class="token number">0</span> <span class="token punctuation">,</span> <span class="token operator">&amp;</span>mask<span class="token punctuation">)</span> <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span>
  <span class="token keyword keyword-return">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>

<span class="token function">myproc</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-&gt;</span> trace_mask <span class="token operator">=</span> mask<span class="token punctuation">;</span>
<span class="token keyword keyword-return">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><p>在kernel/proc.c的<code>fork</code>中添加：</p>
<pre data-role="codeBlock" data-info="c" class="language-c c"><code>np<span class="token operator">-&gt;</span>trace_mask <span class="token operator">=</span> p<span class="token operator">-&gt;</span>trace_mask<span class="token punctuation">;</span>  <span class="token comment">// 复制跟踪掩码到子进程</span>
</code></pre><p>在kernel/syscall.c中添加如下代码：</p>
<pre data-role="codeBlock" data-info="c" class="language-c c"><code><span class="token keyword keyword-extern">extern</span> uint64 <span class="token function">sys_trace</span><span class="token punctuation">(</span><span class="token keyword keyword-void">void</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">// 在static uint64 (*syscalls[])(void)中添加</span>
<span class="token punctuation">[</span>SYS_trace<span class="token punctuation">]</span>   sys_trace<span class="token punctuation">,</span>

<span class="token comment">// 以上两步没有在提示中，不加会编译错误</span>

<span class="token comment">// 系统调用名称，用于后续输出</span>
<span class="token keyword keyword-static">static</span> <span class="token keyword keyword-char">char</span> <span class="token operator">*</span>syscall_names<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token operator">=</span><span class="token punctuation">{</span>
<span class="token punctuation">[</span>SYS_fork<span class="token punctuation">]</span>   <span class="token operator">=</span> <span class="token string">"fork"</span><span class="token punctuation">,</span>
<span class="token punctuation">[</span>SYS_exit<span class="token punctuation">]</span>   <span class="token operator">=</span> <span class="token string">"exit"</span><span class="token punctuation">,</span>
<span class="token punctuation">[</span>SYS_wait<span class="token punctuation">]</span>   <span class="token operator">=</span> <span class="token string">"wait"</span><span class="token punctuation">,</span>
<span class="token punctuation">[</span>SYS_pipe<span class="token punctuation">]</span>   <span class="token operator">=</span> <span class="token string">"pipe"</span><span class="token punctuation">,</span>
<span class="token punctuation">[</span>SYS_read<span class="token punctuation">]</span>   <span class="token operator">=</span> <span class="token string">"read"</span><span class="token punctuation">,</span>
<span class="token punctuation">[</span>SYS_kill<span class="token punctuation">]</span>   <span class="token operator">=</span> <span class="token string">"kill"</span><span class="token punctuation">,</span>
<span class="token punctuation">[</span>SYS_exec<span class="token punctuation">]</span>   <span class="token operator">=</span> <span class="token string">"exec"</span><span class="token punctuation">,</span>
<span class="token punctuation">[</span>SYS_fstat<span class="token punctuation">]</span>  <span class="token operator">=</span> <span class="token string">"fstat"</span><span class="token punctuation">,</span>
<span class="token punctuation">[</span>SYS_chdir<span class="token punctuation">]</span>  <span class="token operator">=</span> <span class="token string">"chdir"</span><span class="token punctuation">,</span>
<span class="token punctuation">[</span>SYS_dup<span class="token punctuation">]</span>    <span class="token operator">=</span> <span class="token string">"dup"</span><span class="token punctuation">,</span>
<span class="token punctuation">[</span>SYS_getpid<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token string">"getpid"</span><span class="token punctuation">,</span>
<span class="token punctuation">[</span>SYS_sbrk<span class="token punctuation">]</span>   <span class="token operator">=</span> <span class="token string">"sbrk"</span><span class="token punctuation">,</span>
<span class="token punctuation">[</span>SYS_sleep<span class="token punctuation">]</span>  <span class="token operator">=</span> <span class="token string">"sleep"</span><span class="token punctuation">,</span>
<span class="token punctuation">[</span>SYS_uptime<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token string">"uptime"</span><span class="token punctuation">,</span>
<span class="token punctuation">[</span>SYS_open<span class="token punctuation">]</span>   <span class="token operator">=</span> <span class="token string">"open"</span><span class="token punctuation">,</span>
<span class="token punctuation">[</span>SYS_write<span class="token punctuation">]</span>  <span class="token operator">=</span> <span class="token string">"write"</span><span class="token punctuation">,</span>
<span class="token punctuation">[</span>SYS_mknod<span class="token punctuation">]</span>  <span class="token operator">=</span> <span class="token string">"mknod"</span><span class="token punctuation">,</span>
<span class="token punctuation">[</span>SYS_unlink<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token string">"unlink"</span><span class="token punctuation">,</span>
<span class="token punctuation">[</span>SYS_link<span class="token punctuation">]</span>   <span class="token operator">=</span> <span class="token string">"link"</span><span class="token punctuation">,</span>
<span class="token punctuation">[</span>SYS_mkdir<span class="token punctuation">]</span>  <span class="token operator">=</span> <span class="token string">"mkdir"</span><span class="token punctuation">,</span>
<span class="token punctuation">[</span>SYS_close<span class="token punctuation">]</span>  <span class="token operator">=</span> <span class="token string">"close"</span><span class="token punctuation">,</span>
<span class="token punctuation">[</span>SYS_trace<span class="token punctuation">]</span>  <span class="token operator">=</span> <span class="token string">"trace"</span><span class="token punctuation">,</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span> 

<span class="token comment">// 修改syscall函数如下</span>
<span class="token keyword keyword-void">void</span>
<span class="token function">syscall</span><span class="token punctuation">(</span><span class="token keyword keyword-void">void</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
<span class="token keyword keyword-int">int</span> num<span class="token punctuation">;</span>
<span class="token keyword keyword-struct">struct</span> <span class="token class-name">proc</span> <span class="token operator">*</span>p <span class="token operator">=</span> <span class="token function">myproc</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

num <span class="token operator">=</span> p<span class="token operator">-&gt;</span>trapframe<span class="token operator">-&gt;</span>a7<span class="token punctuation">;</span> <span class="token comment">//系统调用编号</span>
<span class="token keyword keyword-if">if</span><span class="token punctuation">(</span>num <span class="token operator">&gt;</span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span> num <span class="token operator">&lt;</span> <span class="token function">NELEM</span><span class="token punctuation">(</span>syscalls<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> syscalls<span class="token punctuation">[</span>num<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  p<span class="token operator">-&gt;</span>trapframe<span class="token operator">-&gt;</span>a0 <span class="token operator">=</span> syscalls<span class="token punctuation">[</span>num<span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//系统调用返回值</span>

  <span class="token comment">// 判断当前系统调用是否被追踪，打印追踪信息</span>
  <span class="token keyword keyword-int">int</span> mask <span class="token operator">=</span> p<span class="token operator">-&gt;</span>trace_mask<span class="token punctuation">;</span>
  <span class="token keyword keyword-if">if</span><span class="token punctuation">(</span><span class="token punctuation">(</span>mask <span class="token operator">&amp;</span> <span class="token punctuation">(</span><span class="token number">1</span> <span class="token operator">&lt;&lt;</span> num<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d: syscall %s -&gt; %d\n"</span> <span class="token punctuation">,</span> p<span class="token operator">-&gt;</span>pid <span class="token punctuation">,</span> syscall_names<span class="token punctuation">[</span>num<span class="token punctuation">]</span> <span class="token punctuation">,</span>p<span class="token operator">-&gt;</span>trapframe<span class="token operator">-&gt;</span>a0<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>

<span class="token punctuation">}</span> <span class="token keyword keyword-else">else</span> <span class="token punctuation">{</span>
  <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d %s: unknown sys call %d\n"</span><span class="token punctuation">,</span>
          p<span class="token operator">-&gt;</span>pid<span class="token punctuation">,</span> p<span class="token operator">-&gt;</span>name<span class="token punctuation">,</span> num<span class="token punctuation">)</span><span class="token punctuation">;</span>
  p<span class="token operator">-&gt;</span>trapframe<span class="token operator">-&gt;</span>a0 <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></details>
<details>
<summary>sysinfo</summary>
<p>在user/user.h中添加：</p>
<pre data-role="codeBlock" data-info="c" class="language-c c"><code><span class="token keyword keyword-int">int</span> <span class="token function">sysinfo</span><span class="token punctuation">(</span><span class="token keyword keyword-struct">struct</span> <span class="token class-name">sysinfo</span> <span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><p>在user/usys.pl中添加：</p>
<pre data-role="codeBlock" data-info="pl" class="language-pl pl"><code>entry("sysinfo");
</code></pre><p>在kernel/syscall.h中添加：</p>
<pre data-role="codeBlock" data-info="c" class="language-c c"><code><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">SYS_sysinfo</span> <span class="token expression"><span class="token number">23</span></span></span>
</code></pre><p>在kernel/syscall.c中添加：</p>
<pre data-role="codeBlock" data-info="c" class="language-c c"><code><span class="token keyword keyword-extern">extern</span> uint64 <span class="token function">sys_sysinfo</span><span class="token punctuation">(</span><span class="token keyword keyword-void">void</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// 在static uint64 (*syscalls[])(void) 中添加：</span>
<span class="token punctuation">[</span>SYS_sysinfo<span class="token punctuation">]</span> sys_sysinfo<span class="token punctuation">,</span>

<span class="token comment">// 在static char *syscall_names[]中添加：</span>
<span class="token punctuation">[</span>SYS_sysinfo<span class="token punctuation">]</span><span class="token operator">=</span> <span class="token string">"sysinfo"</span><span class="token punctuation">,</span>
</code></pre><p>在kernel/kalloc.c中添加函数：</p>
<pre data-role="codeBlock" data-info="c" class="language-c c"><code>uint64
<span class="token function">kfreemem</span><span class="token punctuation">(</span><span class="token keyword keyword-void">void</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
<span class="token comment">// 获取空闲内存</span>
<span class="token comment">// 方法是获取空闲的页表数量再乘上页表尺寸</span>

uint64 freemem <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>

<span class="token keyword keyword-struct">struct</span> <span class="token class-name">run</span> <span class="token operator">*</span>r<span class="token punctuation">;</span>
r <span class="token operator">=</span> kmem<span class="token punctuation">.</span>freelist<span class="token punctuation">;</span>

<span class="token keyword keyword-while">while</span><span class="token punctuation">(</span>r<span class="token punctuation">)</span><span class="token punctuation">{</span>
  freemem<span class="token operator">++</span><span class="token punctuation">;</span>
  r <span class="token operator">=</span> r<span class="token operator">-&gt;</span>next<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword keyword-return">return</span> freemem <span class="token operator">*</span> PGSIZE<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><p>在kernel/proc.c中添加函数：</p>
<pre data-role="codeBlock" data-info="c" class="language-c c"><code>uint64
<span class="token function">nproc</span><span class="token punctuation">(</span><span class="token keyword keyword-void">void</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
<span class="token comment">// 获取状态不是UNUSED的进程数</span>
uint64 nproc <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token keyword keyword-for">for</span><span class="token punctuation">(</span><span class="token keyword keyword-int">int</span> i <span class="token operator">=</span> <span class="token number">0</span> <span class="token punctuation">;</span> i <span class="token operator">&lt;</span> NPROC <span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
  <span class="token keyword keyword-if">if</span><span class="token punctuation">(</span>proc<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>state <span class="token operator">!=</span> UNUSED<span class="token punctuation">)</span>
    nproc<span class="token operator">++</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token keyword keyword-return">return</span> nproc<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><p>在kernel/defs.h中声明我们新增的函数，否则编译失败：</p>
<pre data-role="codeBlock" data-info="c" class="language-c c"><code><span class="token comment">// proc.c</span>
uint64          <span class="token function">nproc</span><span class="token punctuation">(</span><span class="token keyword keyword-void">void</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">// kalloc.c</span>
uint64          <span class="token function">kfreemem</span><span class="token punctuation">(</span><span class="token keyword keyword-void">void</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><p>在kernel/sysfile.c中添加如下代码：</p>
<pre data-role="codeBlock" data-info="c" class="language-c c"><code><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"sysinfo.h"</span></span>

uint64
<span class="token function">sys_sysinfo</span><span class="token punctuation">(</span><span class="token keyword keyword-void">void</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span> 
<span class="token comment">// 在用户空间使用系统调用sysinfo(struct sysinfo *)需要传入空的结构体地址</span>
<span class="token comment">// 我们首先在内核中填充sysinfo结构体</span>
<span class="token comment">// 再将其复制到用户空间提供的地址上供用户访问</span>

<span class="token keyword keyword-struct">struct</span> <span class="token class-name">sysinfo</span> sinfo<span class="token punctuation">;</span>
uint64 sy<span class="token punctuation">;</span> <span class="token comment">// 存储指向sysinfo结构体的指针</span>

<span class="token keyword keyword-struct">struct</span> <span class="token class-name">proc</span> <span class="token operator">*</span>p <span class="token operator">=</span> <span class="token function">myproc</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

sinfo<span class="token punctuation">.</span>freemem <span class="token operator">=</span> <span class="token function">kfreemem</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
sinfo<span class="token punctuation">.</span>nproc <span class="token operator">=</span> <span class="token function">nproc</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token keyword keyword-if">if</span><span class="token punctuation">(</span><span class="token function">argaddr</span><span class="token punctuation">(</span><span class="token number">0</span> <span class="token punctuation">,</span> <span class="token operator">&amp;</span>sy<span class="token punctuation">)</span> <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span>
  <span class="token keyword keyword-return">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>

<span class="token keyword keyword-if">if</span><span class="token punctuation">(</span><span class="token function">copyout</span><span class="token punctuation">(</span>p<span class="token operator">-&gt;</span>pagetable <span class="token punctuation">,</span> sy <span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token keyword keyword-char">char</span> <span class="token operator">*</span><span class="token punctuation">)</span><span class="token operator">&amp;</span>sinfo <span class="token punctuation">,</span> <span class="token keyword keyword-sizeof">sizeof</span><span class="token punctuation">(</span>sinfo<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span>
  <span class="token keyword keyword-return">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>
<span class="token keyword keyword-return">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></details>
<h1 id="lec4">LEC4 </h1>
<h2 id="页表">页表 </h2>
<p>每个进程有一个39位的虚拟地址，它对应于一个56位的物理地址；<br>
（设计56位物理地址，是为日后内存扩大做准备，实际上并不是都放了东西）<br>
39位的虚拟地址会按照后12位，也就是<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mn>2</mn><mn>12</mn></msup></mrow><annotation encoding="application/x-tex">2^{12}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">12</span></span></span></span></span></span></span></span></span></span></span></span>个分成一组；<br>
这样的一组我们用PTE来表示；<br>
物理地址中的后12位和虚拟地址中的后12位是完全一样的，因此我们只需要知道虚拟地址中39位的前27位对应的物理地址中的前44位是什么就可以；<br>
每个进程有一个页表（Page Table），页表中存储的就是这个27位到44位的映射信息；<br>
因此页表有<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mn>2</mn><mn>2</mn></msup><mn>7</mn></mrow><annotation encoding="application/x-tex">2^27</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mord">7</span></span></span></span>项，每一项对应虚拟地址中39位的前27位中的1个，即1个PTE；<br>
每个PTE有54位，其中前44位就是每个PTE对应的物理地址的前44位，称为PPN，后10位是标志位flag；<br>
实际情况下，用8个字节（64位）来存储一个PTE，因此页表相当于一个数组uint64 a[1&lt;&lt;27]，它所占据的内存大小是1GB;<br>
<img src="..\assets\images\s.6081\image-3.png" alt="alt text"><br>
用1GB来存储一个进程的页表显然是不可接受的，实际使用三级页表的方式来优化存储：<br>
首先我们有一个44位的起始地址d，地址以1个字节为单位，它被预先存储在每个CPU的<code>satp</code>中；<br>
我们获取27位中的前9位，它对应十进制的a1；<br>
我们可以得到地址<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>d</mi><mo>+</mo><mi>a</mi><mn>1</mn><mo>×</mo><mn>8</mn></mrow><annotation encoding="application/x-tex">d+a1\times8</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7778em;vertical-align:-0.0833em;"></span><span class="mord mathnormal">d</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.7278em;vertical-align:-0.0833em;"></span><span class="mord mathnormal">a</span><span class="mord">1</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">8</span></span></span></span>开始的8个字节存储的64位数，提取其中的44位作为地址d1；<br>
获取27位中的中间9位，它对应十进制的a2;<br>
我们可以得到地址<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>d</mi><mn>1</mn><mo>+</mo><mi>a</mi><mn>2</mn><mo>×</mo><mn>8</mn></mrow><annotation encoding="application/x-tex">d1+a2\times8</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7778em;vertical-align:-0.0833em;"></span><span class="mord mathnormal">d</span><span class="mord">1</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.7278em;vertical-align:-0.0833em;"></span><span class="mord mathnormal">a</span><span class="mord">2</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">8</span></span></span></span>开始的8个字节存储的64位数，提取其中的44位作为地址d2；<br>
获取27位中的最后9位，它对应十进制的a3;<br>
我们可以得到地址<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>d</mi><mn>2</mn><mo>+</mo><mi>a</mi><mn>3</mn><mo>×</mo><mn>8</mn></mrow><annotation encoding="application/x-tex">d2+a3\times8</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7778em;vertical-align:-0.0833em;"></span><span class="mord mathnormal">d</span><span class="mord">2</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.7278em;vertical-align:-0.0833em;"></span><span class="mord mathnormal">a</span><span class="mord">3</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">8</span></span></span></span>开始的8个字节，这就是我们最后所需要的那8个字节；<br>
具体图示如下：<br>
<img src="..\assets\images\s.6081\image-4.png" alt="alt text"><br>
为什么这么做能节省内存？<br>
原则上，如果我们能够预知虚拟内存中有多少页需要被使用，只为那些被使用的页分配内存是最节约的；<br>
然而实际上，我们在分配内存时，并不知道有多少页需要被使用，为了不引发错误，必须使用足够多的空间；<br>
三级页表提供了一种“按需分配”的方法，只有当a1被使用时，a1所对应的d1起始的内存才需要被关注，否则我们无需关心d1起始的内存里面存了什么东西；<br>
因此，只有d起始的那些内存是一开始必须要写好的，其余部分都是a1a2a3中声明了哪些，才存哪些；<br>
<img src="..\assets\images\s.6081\image-5.png" alt="alt text"><br>
我们知道每个PTE中对应的是一个64位数，其中的后10位是标志位，用来告诉硬件如何使用关联的虚拟地址；<br>
PTE_V指示是否存在该PTE；<br>
PTE_R控制是由允许读取页面；<br>
PTE_W控制是否允许写入页面；<br>
PTE_X控制是否允许CPU解释并执行页面；<br>
PTE_U控制是否允许用户模式下访问，如果未设置，只能在管理模式下访问。</p>
<h2 id="页表缓存">页表缓存 </h2>
<p>上面的过程，我们需要查三次，也就是读三次内存，因此代价比较高；<br>
实际上，对于所有处理器，都会对最近使用的虚拟地址的映射结果进行缓存，称之为TLB；<br>
处理器第一次查找一个虚拟地址时，通过三次查询找到了最终的物理地址，TLB会保存这种映射关系；<br>
下一次访问相同的虚拟地址时，处理器可以直接查看TLB返回物理地址，无需通过页表查询；</p>
<h2 id="内核地址空间">内核地址空间 </h2>
<p>我们知道页表实现的是虚拟地址到物理地址之间的映射；<br>
上一节我们知道每个进程都有一个页表，完成的是各自的用户空间虚拟地址到物理地址之间的映射；<br>
但是进程不止在用户空间中，还会进入内核中；<br>
因此每个进程的页表，不仅有用户空间虚拟地址到物理地址之间的映射，还有内核空间虚拟地址到物理地址之间的映射；<br>
而从内核空间虚拟地址到物理地址之间的映射对于所有进程而言是相同的。</p>
<p>内核空间的页表有一套固定的规则，物理地址中哪些被内核所占用是确定的；<br>
而进程的用户页表是内核交给它的，只有通过内核分配的用户页表，每个进程才知道自己的用户空间地址对应于哪一部分物理地址；</p>
<p>内核空间的页表的映射关系如下：<br>
<img src="..\assets\images\s.6081\image-6.png" alt="alt text"><br>
内核虚拟地址右侧的R,X,W表明是否具备读、执行、写权限；</p>
<p>大部分虚拟地址映射到物理内存（RAM）中，但是也有少部分KERNBASE以下的映射；<br>
这些映射表明，内核并不是与RAM交互，而是直接与下面的硬件设备交互的；</p>
<p>大部分内核空间的映射为直接映射，即内核空间虚拟地址等于物理地址；<br>
但是也存在特殊情况，比如多个虚拟地址映射到同一个物理地址，或者虚拟地址不对应物理地址，具体如下：</p>
<p><strong>蹦床页面（trampoline）</strong><br>
物理地址上，它存放着用户态和内核态之间切换的代码，在RAM中；<br>
它一方面可以由Kernel text部分的内核虚拟地址直接映射；<br>
另一方面，内核虚拟地址的顶部的虚拟地址也映射向同一部分物理地址；<br>
放在内核虚拟空间的顶部是因为它们和用户空间的顶部虚拟地址是一样的；<br>
这能够保证内核在执行完虚拟地址顶部对应的切换代码之后，所处的虚拟地址，对于用户空间而言也是合法的；<br>
同理，用户在执行完顶部的虚拟地址顶部对应的切换代码之后，所处的虚拟地址，对于内核空间而言也是合法的；</p>
<p><strong>内核栈页面</strong><br>
进程进入内核时，需要用到内核中的内核栈；<br>
内核栈上下有保护页，这些保护页只有虚拟地址，没有物理地址；<br>
因此一旦内核栈太深，溢出的内容写到保护页上；<br>
但是保护页没有PTE_V标志，无法映射到物理内存；<br>
CPU会触发异常，导致内核崩溃；<br>
这样的设计可以有效防止内核栈溢出内容覆盖内核其他部分。</p>
<h2 id="地址空间管理">地址空间管理 </h2>
<p>我们现在概括一下前两节所讲的内容：<br>
核心是要知道一个虚拟地址如何定位到一个物理地址上；<br>
用的工具是页表（Page Table），它是一段内存，大小是4KB；<br>
这4KB的内存的划分是512个8字节，每一个8字节64位数为1个PTE；<br>
每个PTE的后10位是标志位，中间44位是物理内存的前44位；</p>
<p>我们只需要指向第一级页表的起始物理地址的指针，就可以根据虚拟地址中的前27位，三次调用得到最终的PTE；<br>
再用PTE中的44为物理地址，和虚拟地址中的后12位，拼接得到最终的物理地址；</p>
<p>以上对于用户空间和内核空间的工作流程都是一样的，映射方式取决于PTE中填的是什么；</p>
<p>实际情况下我们会面临两个问题：<br>
（1）PTE都在内存中存好了，告知一个虚拟地址和初始的页表指针，一路查出物理地址是什么；<br>
这通常用于用户空间想要执行程序的过程；<br>
（2）物理地址安排好了，虚拟地址也规定好了，要在内存中写入PTE的值，便于后续用内存中的PTE反过来查出物理地址；<br>
这通常对应于设置内核的过程，因为内核的虚拟地址和物理地址的关系是直接且被预设好的；<br>
同时，在启动一个进程时，我们也为其分配好了物理地址，需要设置好PTE；<br>
注意，要用哪些虚拟地址，才会相应地分配PTE；</p>
<p>在代码实现中，<code>pagetable_t</code>是指向页表的指针，也就是页表的初始地址；<br>
kvm开头的函数与内核虚拟地址相关，uvm开头的函数与用户虚拟地址相关；<br>
<code>walk</code>:用虚拟地址和<code>pagetable_t</code>查出PTE；</p>
<p><code>mappages</code>:给定<code>pagetable_t</code>，虚拟地址和物理地址，把中间需要的那些PTE设置好；</p>
<p><code>kvminit</code>:创建内核的页表，用<code>kvmmap</code>实现映射；</p>
<p><code>kvminithart</code>:把内核的页表的初始物理地址写到CPU的寄存器satp中；</p>
<p><code>procinit</code>:为进程分配内核栈，也就是声明一部分内核虚拟地址的映射（用<code>kvmmap</code>实现），填上相应的PTE，注意要留好guard pages;完成之后，要重新调用<code>kvminithart</code>把内核的页表的初始物理地址写到CPU的寄存器satp中；</p>
<p>上面的最后一步是让人疑惑的，实际上这个初始地址没有变，那为什么还要再调用一次<code>kvminithart</code>呢？<br>
这是因为为进程分配内核栈，实际上改变了一部分内核虚拟空间到物理空间的映射，而这部分映射很可能被保存在了TLB中，我们要让它恢复过来；<br>
<code>kvminithart</code>中调用了<code>sfence.vma()</code>函数，这个函数的功能就是取消当前的TLB；</p>
<p>但是这同样让人疑惑，为什么在为进程分配内核栈的时候要改变内核虚拟空间到物理空间的映射呢？我们不能把这部分映射固定下来，每次把内核栈的虚拟空间分给新的进程不行吗？<br>
这会有泄漏风险，内核栈使用完毕后，对应的物理空间必须释放掉；<br>
否则，当不同进程使用同一内核栈的虚拟地址，且映射到的还是相同的物理地址的话，没被清理掉的物理地址上的内容就会干扰当前进程。</p>
<h2 id="物理内存分配">物理内存分配 </h2>
<p>在运行过程中，要不断地对内核末尾和PHYSTOP之间的物理空间分配内存；<br>
分配以页（4KB）为单位；<br>
分配和释放通过追踪空闲页链表实现；<br>
分配就是从链表中移除一个页；<br>
释放就是增添一页到链表中；</p>
<p>分配器在kernel/kalloc.c中；<br>
每一个链表中的元素，也就是一个页，被定义为<code>struct run</code>;<br>
这个结构体被存在空闲页里，那里除此之外没有其他东西；</p>
<p><code>kfree</code>：把内存中每个字节设置为1，表明这段内存被释放；<br>
然后把页面查到空闲链表的最前面，也就是把当前物理地址指向空闲链表的表头，并把自己当作表头；</p>
<p><code>kinit</code>:调用<code>freearange</code>确保释放的物理地址是对齐的，并为每一页调用<code>kfree</code>;</p>
<p><code>kalloc</code>:删除并返回空闲链表的表头；</p>
<h2 id="进程地址空间">进程地址空间 </h2>
<p><img src="..\assets\images\s.6081\image-7.png" alt="alt text"><br>
heap中的虚拟地址的使用范围是可以被扩大或缩小的；<br>
进程索要内存，指的就是扩大heap中虚拟地址的使用，为其分配物理空间；</p>
<p>用户栈中存储的是这个进程执行的那些命令；<br>
栈的下方有一个guard page，一旦溢出，会导致访问到无效的页，触发页面故障；<br>
注意栈的地址使用是从上到下用的；</p>
<p><code>sbrk</code>:可以扩大或减小进程用户空间的system call；<br>
系统调用由<code>growproc</code>实现；<br>
具体地，根据扩大还是缩小，调用<code>uvmalloc</code>和<code>uvmdealloc</code>;<br>
前者使用<code>kalloc</code>分配物理内存，并使用<code>mappages</code>设置好PTE；<br>
后者调用<code>uvmunmap</code>,该函数使用<code>walk</code>得到PTE，得到对应的物理内存，再使用<code>kfree</code>释放物理内存。</p>
<p><code>exec</code>:一个system call,为ELF格式文件创建用户空间；<br>
先检查是否有ELF_MAGIC，判断是否为ELF格式二进制文件；<br>
用<code>proc_pagetable </code>分配页表，也就是最高级页表的初始物理地址；<br>
用<code>uvmalloc</code>为ELF段分配物理地址，创建映射，然后用<code>loadseg</code>把这些内容加载到内存中；<br>
分配初始化用户栈，只分配一个页面，下方有guard page；<br>
如果检测到错误，<code>exec</code>会把新创建的页表摄者为-1，只有新的执行成功，才会释放掉旧进程的页表。</p>
<h2 id="lab3-page-tables">Lab3 ：page tables </h2>
<p>点击可以展开各个实验的具体代码实现：</p>
<details>
<summary>vmprint</summary>
<p>在kernel/defs.h中添加：</p>
<pre data-role="codeBlock" data-info="c" class="language-c c"><code><span class="token comment">// vm.c</span>
<span class="token keyword keyword-void">void</span>            <span class="token function">vmprint</span><span class="token punctuation">(</span><span class="token class-name">pagetable_t</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><p>在kernel/exec.c的118行处,<code>return argc</code>之前加上：</p>
<pre data-role="codeBlock" data-info="c" class="language-c c"><code><span class="token comment">// 打印第一个进程的页表</span>
<span class="token keyword keyword-if">if</span><span class="token punctuation">(</span>p<span class="token operator">-&gt;</span>pid <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">)</span>
  <span class="token function">vmprint</span><span class="token punctuation">(</span>p<span class="token operator">-&gt;</span>pagetable<span class="token punctuation">)</span><span class="token punctuation">;</span>

</code></pre><p>在kernel/vm.c中添加：</p>
<pre data-role="codeBlock" data-info="c" class="language-c c"><code><span class="token keyword keyword-void">void</span>
<span class="token function">vmprint_depth</span><span class="token punctuation">(</span><span class="token class-name">pagetable_t</span> pagetable <span class="token punctuation">,</span> <span class="token keyword keyword-int">int</span> depth<span class="token punctuation">)</span><span class="token punctuation">{</span>
depth<span class="token operator">++</span><span class="token punctuation">;</span>
<span class="token keyword keyword-for">for</span><span class="token punctuation">(</span><span class="token keyword keyword-int">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">512</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
  <span class="token class-name">pte_t</span> pte <span class="token operator">=</span> pagetable<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>

  <span class="token keyword keyword-if">if</span><span class="token punctuation">(</span><span class="token punctuation">(</span>pte <span class="token operator">&amp;</span> PTE_V<span class="token punctuation">)</span> <span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token comment">// 判断合法性</span>
    
    uint64 child <span class="token operator">=</span> <span class="token function">PTE2PA</span><span class="token punctuation">(</span>pte<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">// (((pte) &gt;&gt; 10) &lt;&lt; 12)</span>

    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">".."</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword keyword-for">for</span><span class="token punctuation">(</span><span class="token keyword keyword-int">int</span> j <span class="token operator">=</span> <span class="token number">1</span> <span class="token punctuation">;</span> j <span class="token operator">&lt;</span> depth <span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span>
      <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">" .."</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d: pte %p pa %p\n"</span> <span class="token punctuation">,</span> i <span class="token punctuation">,</span> pte<span class="token punctuation">,</span> child<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword keyword-if">if</span><span class="token punctuation">(</span>depth <span class="token operator">&lt;</span> <span class="token number">3</span><span class="token punctuation">)</span>
      <span class="token function">vmprint_depth</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token class-name">pagetable_t</span><span class="token punctuation">)</span>child <span class="token punctuation">,</span> depth<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword keyword-void">void</span>
<span class="token function">vmprint</span><span class="token punctuation">(</span><span class="token class-name">pagetable_t</span> pagetable<span class="token punctuation">)</span><span class="token punctuation">{</span>
<span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"page table %p\n"</span> <span class="token punctuation">,</span> pagetable<span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">// 需要追踪深度，所以需要定义辅助函数</span>
<span class="token function">vmprint_depth</span><span class="token punctuation">(</span>pagetable <span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></details>
<details>
<summary>a kernel pagetable per process</summary>
<p>在kernel/proc.h的<code>struct proc</code>中添加：</p>
<pre data-role="codeBlock" data-info="c" class="language-c c"><code><span class="token comment">// 添加内核页表副本</span>
<span class="token class-name">pagetable_t</span> kpt<span class="token punctuation">;</span>
</code></pre><p>在kernel/vm.c中添加：</p>
<pre data-role="codeBlock" data-info="c" class="language-c c"><code><span class="token class-name">pagetable_t</span>
<span class="token function">proc_kvminit</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
<span class="token comment">// 初始化进程的内核副本</span>
<span class="token class-name">pagetable_t</span> kpt<span class="token punctuation">;</span>
kpt <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token class-name">pagetable_t</span><span class="token punctuation">)</span> <span class="token function">kalloc</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token function">memset</span><span class="token punctuation">(</span>kpt<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> PGSIZE<span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">// 这里非常坑，mappages中的参数顺序和上面的kvmmap中的不一样！！！</span>
<span class="token function">mappages</span><span class="token punctuation">(</span>kpt<span class="token punctuation">,</span> UART0<span class="token punctuation">,</span>  PGSIZE<span class="token punctuation">,</span>UART0<span class="token punctuation">,</span> PTE_R <span class="token operator">|</span> PTE_W<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token function">mappages</span><span class="token punctuation">(</span>kpt<span class="token punctuation">,</span> VIRTIO0<span class="token punctuation">,</span>  PGSIZE<span class="token punctuation">,</span>VIRTIO0<span class="token punctuation">,</span> PTE_R <span class="token operator">|</span> PTE_W<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token function">mappages</span><span class="token punctuation">(</span>kpt<span class="token punctuation">,</span> CLINT<span class="token punctuation">,</span>  <span class="token number">0x10000</span><span class="token punctuation">,</span>CLINT<span class="token punctuation">,</span> PTE_R <span class="token operator">|</span> PTE_W<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token function">mappages</span><span class="token punctuation">(</span>kpt<span class="token punctuation">,</span> PLIC<span class="token punctuation">,</span>  <span class="token number">0x400000</span><span class="token punctuation">,</span>PLIC<span class="token punctuation">,</span> PTE_R <span class="token operator">|</span> PTE_W<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token function">mappages</span><span class="token punctuation">(</span>kpt<span class="token punctuation">,</span> KERNBASE<span class="token punctuation">,</span>  <span class="token punctuation">(</span>uint64<span class="token punctuation">)</span>etext<span class="token operator">-</span>KERNBASE<span class="token punctuation">,</span>KERNBASE<span class="token punctuation">,</span> PTE_R <span class="token operator">|</span> PTE_X<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token function">mappages</span><span class="token punctuation">(</span>kpt<span class="token punctuation">,</span> <span class="token punctuation">(</span>uint64<span class="token punctuation">)</span>etext<span class="token punctuation">,</span>  PHYSTOP<span class="token operator">-</span><span class="token punctuation">(</span>uint64<span class="token punctuation">)</span>etext<span class="token punctuation">,</span><span class="token punctuation">(</span>uint64<span class="token punctuation">)</span>etext<span class="token punctuation">,</span> PTE_R <span class="token operator">|</span> PTE_W<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token function">mappages</span><span class="token punctuation">(</span>kpt<span class="token punctuation">,</span> TRAMPOLINE<span class="token punctuation">,</span>  PGSIZE<span class="token punctuation">,</span><span class="token punctuation">(</span>uint64<span class="token punctuation">)</span>trampoline<span class="token punctuation">,</span> PTE_R <span class="token operator">|</span> PTE_X<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword keyword-return">return</span> kpt<span class="token punctuation">;</span>
<span class="token comment">// 需要返回，否则只是修改了局部变量</span>
<span class="token punctuation">}</span>

<span class="token comment">// !!!要修改kvmpa函数</span>
uint64
<span class="token function">kvmpa</span><span class="token punctuation">(</span><span class="token class-name">pagetable_t</span> kernel_pagetable <span class="token punctuation">,</span> uint64 va<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
<span class="token comment">// 这个函数的作用是将内核虚拟地址映射到物理地址中</span>
uint64 off <span class="token operator">=</span> va <span class="token operator">%</span> PGSIZE<span class="token punctuation">;</span>
<span class="token class-name">pte_t</span> <span class="token operator">*</span>pte<span class="token punctuation">;</span>
uint64 pa<span class="token punctuation">;</span>

<span class="token comment">// 这里非常坑！！！</span>
<span class="token comment">// 题目中没有提示，如果使用全局变量会出错</span>
<span class="token comment">// 必须使用当前的内核副本</span>
pte <span class="token operator">=</span> <span class="token function">walk</span><span class="token punctuation">(</span>kernel_pagetable<span class="token punctuation">,</span> va<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword keyword-if">if</span><span class="token punctuation">(</span>pte <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span>
  <span class="token function">panic</span><span class="token punctuation">(</span><span class="token string">"kvmpa"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword keyword-if">if</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token operator">*</span>pte <span class="token operator">&amp;</span> PTE_V<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span>
  <span class="token function">panic</span><span class="token punctuation">(</span><span class="token string">"kvmpa"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
pa <span class="token operator">=</span> <span class="token function">PTE2PA</span><span class="token punctuation">(</span><span class="token operator">*</span>pte<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword keyword-return">return</span> pa<span class="token operator">+</span>off<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><p>上面修改了<code>kvmpa</code>函数，需要相应修改kernel/virtio_disk.c：</p>
<pre data-role="codeBlock" data-info="c" class="language-c c"><code><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"proc.h"</span></span>
<span class="token comment">// 补充头文件，注意得补在最后面</span>

<span class="token comment">// 208行左右的位置</span>
disk<span class="token punctuation">.</span>desc<span class="token punctuation">[</span>idx<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">.</span>addr <span class="token operator">=</span> <span class="token punctuation">(</span>uint64<span class="token punctuation">)</span> <span class="token function">kvmpa</span><span class="token punctuation">(</span><span class="token function">myproc</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">-&gt;</span>kpt <span class="token punctuation">,</span> <span class="token punctuation">(</span>uint64<span class="token punctuation">)</span> <span class="token operator">&amp;</span>buf0<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// 之前我们修改了kvmpa函数，这里必须调整过来</span>
</code></pre><p>在kernel/defs.h中修改和添加：</p>
<pre data-role="codeBlock" data-info="c" class="language-c c"><code>uint64          <span class="token function">kvmpa</span><span class="token punctuation">(</span><span class="token class-name">pagetable_t</span> <span class="token punctuation">,</span> uint64<span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token class-name">pagetable_t</span>     <span class="token function">proc_kvminit</span><span class="token punctuation">(</span><span class="token keyword keyword-void">void</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><p>在kernel/proc.c中修改和添加：</p>
<pre data-role="codeBlock" data-info="c" class="language-c c"><code><span class="token keyword keyword-void">void</span>
<span class="token function">procinit</span><span class="token punctuation">(</span><span class="token keyword keyword-void">void</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
<span class="token comment">// 原先的设计是把每个进程的内核栈存在一个内核虚拟空间中</span>
<span class="token comment">// 现在需要把内核每个进程的内核栈存在各自的内核副本中</span>

<span class="token comment">// 原先是在procinit中为每个进程分配好内核栈</span>
<span class="token comment">// 修改后，在每个allocproc中，为一个进程分配它自己的内核副本页表上的内核栈</span>

<span class="token keyword keyword-struct">struct</span> <span class="token class-name">proc</span> <span class="token operator">*</span>p<span class="token punctuation">;</span>

<span class="token function">initlock</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>pid_lock<span class="token punctuation">,</span> <span class="token string">"nextpid"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword keyword-for">for</span><span class="token punctuation">(</span>p <span class="token operator">=</span> proc<span class="token punctuation">;</span> p <span class="token operator">&lt;</span> <span class="token operator">&amp;</span>proc<span class="token punctuation">[</span>NPROC<span class="token punctuation">]</span><span class="token punctuation">;</span> p<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token function">initlock</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>p<span class="token operator">-&gt;</span>lock<span class="token punctuation">,</span> <span class="token string">"proc"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">/*
    // 分配内核栈的功能在各自的allocproc中实现
    // Allocate a page for the process's kernel stack.
    // Map it high in memory, followed by an invalid
    // guard page.
    char *pa = kalloc();
    if(pa == 0)
      panic("kalloc");
    uint64 va = KSTACK((int) (p - proc));
    kvmmap(va, (uint64)pa, PGSIZE, PTE_R | PTE_W);
    p-&gt;kstack = va;
    */</span>
<span class="token punctuation">}</span>

<span class="token function">kvminithart</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token comment">// 在allocproc函数中修改</span>
found<span class="token operator">:</span>
p<span class="token operator">-&gt;</span>pid <span class="token operator">=</span> <span class="token function">allocpid</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">// Allocate a trapframe page.</span>
<span class="token keyword keyword-if">if</span><span class="token punctuation">(</span><span class="token punctuation">(</span>p<span class="token operator">-&gt;</span>trapframe <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword keyword-struct">struct</span> <span class="token class-name">trapframe</span> <span class="token operator">*</span><span class="token punctuation">)</span><span class="token function">kalloc</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
  <span class="token function">release</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>p<span class="token operator">-&gt;</span>lock<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword keyword-return">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token comment">// An empty user page table.</span>
p<span class="token operator">-&gt;</span>pagetable <span class="token operator">=</span> <span class="token function">proc_pagetable</span><span class="token punctuation">(</span>p<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword keyword-if">if</span><span class="token punctuation">(</span>p<span class="token operator">-&gt;</span>pagetable <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
  <span class="token function">freeproc</span><span class="token punctuation">(</span>p<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token function">release</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>p<span class="token operator">-&gt;</span>lock<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword keyword-return">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

p<span class="token operator">-&gt;</span>kpt <span class="token operator">=</span> <span class="token function">proc_kvminit</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">// 为每个进程的内核副本分配内核栈</span>

<span class="token keyword keyword-char">char</span> <span class="token operator">*</span>pa <span class="token operator">=</span> <span class="token function">kalloc</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword keyword-if">if</span><span class="token punctuation">(</span>pa <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span>
  <span class="token function">panic</span><span class="token punctuation">(</span><span class="token string">"kalloc"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
uint64 va <span class="token operator">=</span> <span class="token function">KSTACK</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token keyword keyword-int">int</span><span class="token punctuation">)</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// 设为0即可，因为现在内核栈是独属于某个进程的</span>
<span class="token function">mappages</span><span class="token punctuation">(</span>p<span class="token operator">-&gt;</span>kpt<span class="token punctuation">,</span> va<span class="token punctuation">,</span>  PGSIZE<span class="token punctuation">,</span><span class="token punctuation">(</span>uint64<span class="token punctuation">)</span>pa<span class="token punctuation">,</span> PTE_R <span class="token operator">|</span> PTE_W<span class="token punctuation">)</span><span class="token punctuation">;</span>
p<span class="token operator">-&gt;</span>kstack <span class="token operator">=</span> va<span class="token punctuation">;</span>
<span class="token comment">// 寄存器的值在scheduler()中统一调度</span>

<span class="token comment">// 注意放的位置，不能放在最后</span>
<span class="token comment">// 后续中p-&gt;contxt.sp使用到了p-&gt;kstack，所以需要在前面设置</span>

<span class="token comment">// Set up new context to start executing at forkret,</span>
<span class="token comment">// which returns to user space.</span>
<span class="token function">memset</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>p<span class="token operator">-&gt;</span>context<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token keyword keyword-sizeof">sizeof</span><span class="token punctuation">(</span>p<span class="token operator">-&gt;</span>context<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
p<span class="token operator">-&gt;</span>context<span class="token punctuation">.</span>ra <span class="token operator">=</span> <span class="token punctuation">(</span>uint64<span class="token punctuation">)</span>forkret<span class="token punctuation">;</span>
p<span class="token operator">-&gt;</span>context<span class="token punctuation">.</span>sp <span class="token operator">=</span> p<span class="token operator">-&gt;</span>kstack <span class="token operator">+</span> PGSIZE<span class="token punctuation">;</span>

<span class="token keyword keyword-return">return</span> p<span class="token punctuation">;</span>

<span class="token comment">// 在scheduler函数中修改</span>
<span class="token keyword keyword-for">for</span><span class="token punctuation">(</span>p <span class="token operator">=</span> proc<span class="token punctuation">;</span> p <span class="token operator">&lt;</span> <span class="token operator">&amp;</span>proc<span class="token punctuation">[</span>NPROC<span class="token punctuation">]</span><span class="token punctuation">;</span> p<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token function">acquire</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>p<span class="token operator">-&gt;</span>lock<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword keyword-if">if</span><span class="token punctuation">(</span>p<span class="token operator">-&gt;</span>state <span class="token operator">==</span> RUNNABLE<span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token comment">// Switch to chosen process.  It is the process's job</span>
      <span class="token comment">// to release its lock and then reacquire it</span>
      <span class="token comment">// before jumping back to us.</span>
      p<span class="token operator">-&gt;</span>state <span class="token operator">=</span> RUNNING<span class="token punctuation">;</span>
      c<span class="token operator">-&gt;</span>proc <span class="token operator">=</span> p<span class="token punctuation">;</span>

      <span class="token comment">// 进程每一次进入running状态，都要把内核页表加载到寄存器中</span>
      <span class="token comment">// 这和原本的设计是不同的</span>
      <span class="token comment">// 原本的设计中共用一个内核页表，因此寄存器里面一直都是那个内核页表</span>
      <span class="token comment">// 只要其中的映射不便，无需更新重置TBL</span>
      <span class="token comment">// 而现在，寄存器中必须放入当前处理的进程的内核页表</span>
      <span class="token comment">// 注意要放在切换进程之前</span>

      <span class="token function">w_satp</span><span class="token punctuation">(</span><span class="token function">MAKE_SATP</span><span class="token punctuation">(</span>p<span class="token operator">-&gt;</span>kpt<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token function">sfence_vma</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

      <span class="token function">swtch</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>c<span class="token operator">-&gt;</span>context<span class="token punctuation">,</span> <span class="token operator">&amp;</span>p<span class="token operator">-&gt;</span>context<span class="token punctuation">)</span><span class="token punctuation">;</span>

      <span class="token comment">// Process is done running for now.</span>
      <span class="token comment">// It should have changed its p-&gt;state before coming back.</span>
      c<span class="token operator">-&gt;</span>proc <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>

      found <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token function">release</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>p<span class="token operator">-&gt;</span>lock<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
  <span class="token keyword keyword-if">if</span><span class="token punctuation">(</span>found <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token comment">// 如果没有进程，传入全局内核进入寄存器中</span>
    <span class="token function">kvminithart</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>

<span class="token comment">// 添加函数，放在freeproc之前</span>
<span class="token keyword keyword-void">void</span>
<span class="token function">freewalk_kproc</span><span class="token punctuation">(</span><span class="token class-name">pagetable_t</span> pagetable<span class="token punctuation">)</span> <span class="token punctuation">{</span>
<span class="token comment">// 清空页表，但是保留物理地址中的东西</span>
<span class="token keyword keyword-for">for</span><span class="token punctuation">(</span><span class="token keyword keyword-int">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">512</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
  <span class="token class-name">pte_t</span> pte <span class="token operator">=</span> pagetable<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>
  <span class="token keyword keyword-if">if</span><span class="token punctuation">(</span><span class="token punctuation">(</span>pte <span class="token operator">&amp;</span> PTE_V<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    pagetable<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
    <span class="token keyword keyword-if">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>pte <span class="token operator">&amp;</span> <span class="token punctuation">(</span>PTE_R<span class="token operator">|</span>PTE_W<span class="token operator">|</span>PTE_X<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span>
    <span class="token punctuation">{</span> 
      <span class="token comment">// 只在非叶节点的时候进入递归</span>
      uint64 child <span class="token operator">=</span> <span class="token function">PTE2PA</span><span class="token punctuation">(</span>pte<span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token function">freewalk_kproc</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token class-name">pagetable_t</span><span class="token punctuation">)</span>child<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span class="token comment">// 清空当前页表</span>
<span class="token function">kfree</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token keyword keyword-void">void</span><span class="token operator">*</span><span class="token punctuation">)</span>pagetable<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token comment">// 修改freeproc函数</span>
p<span class="token operator">-&gt;</span>pagetable <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
p<span class="token operator">-&gt;</span>sz <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
p<span class="token operator">-&gt;</span>pid <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
p<span class="token operator">-&gt;</span>parent <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
p<span class="token operator">-&gt;</span>name<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
p<span class="token operator">-&gt;</span>chan <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
p<span class="token operator">-&gt;</span>killed <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
p<span class="token operator">-&gt;</span>xstate <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>

<span class="token comment">// 要单独现把内核栈释放掉，因为内核栈需要彻底释放</span>
<span class="token comment">// 清空对应的物理内存</span>
<span class="token keyword keyword-if">if</span> <span class="token punctuation">(</span>p<span class="token operator">-&gt;</span>kstack<span class="token punctuation">)</span>
  <span class="token function">uvmunmap</span><span class="token punctuation">(</span>p<span class="token operator">-&gt;</span>kpt <span class="token punctuation">,</span> p<span class="token operator">-&gt;</span>kstack <span class="token punctuation">,</span> <span class="token number">1</span> <span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
p<span class="token operator">-&gt;</span>kstack <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>

<span class="token comment">// 这里要注意，不能把物理内存里面的东西给释放掉，里面放的是内核</span>
<span class="token comment">// 但是前几层的页表得释放掉，不能只是把p-&gt;kpt = 0</span>
<span class="token keyword keyword-if">if</span><span class="token punctuation">(</span>p<span class="token operator">-&gt;</span>kpt<span class="token punctuation">)</span>
  <span class="token function">freewalk_kproc</span><span class="token punctuation">(</span>p<span class="token operator">-&gt;</span>kpt<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// p-&gt;kpt = 0;</span>

p<span class="token operator">-&gt;</span>state <span class="token operator">=</span> UNUSED<span class="token punctuation">;</span>
</code></pre><p>使用<code>usertests</code>可以检测，注意测试会故意传入无效地址，只要最后All tests passed就行</p>
</details>
<details>
<summary>simplify</summary>
<p>修改kernel/vm.c中的copyin , copystrin：</p>
<pre data-role="codeBlock" data-info="c" class="language-c c"><code><span class="token comment">// 原来的复制逻辑是要先找到用户空间虚拟地址对应的物理地址</span>
<span class="token comment">// 这个实验想达到的目的是把用户空间虚拟地址到物理地址的映射，加到对应进程的内核页表中去</span>
<span class="token comment">// 从而可以直接使用用户空间虚拟地址,因为在内核页表中,这个虚拟地址也是有映射的,可以使用</span>

<span class="token comment">// 这一步其实什么都没做,就是修改了一下引用用户空间的逻辑</span>
<span class="token comment">// 真正要做的是后续步骤,也就是把用户空间页表同步到进程的内核页表中</span>

<span class="token keyword keyword-int">int</span>
<span class="token function">copyin</span><span class="token punctuation">(</span><span class="token class-name">pagetable_t</span> pagetable<span class="token punctuation">,</span> <span class="token keyword keyword-char">char</span> <span class="token operator">*</span>dst<span class="token punctuation">,</span> uint64 srcva<span class="token punctuation">,</span> uint64 len<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
<span class="token keyword keyword-return">return</span> <span class="token function">copyin_new</span><span class="token punctuation">(</span>pagetable <span class="token punctuation">,</span> dst <span class="token punctuation">,</span> srcva <span class="token punctuation">,</span> len<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword keyword-int">int</span>
<span class="token function">copyinstr</span><span class="token punctuation">(</span><span class="token class-name">pagetable_t</span> pagetable<span class="token punctuation">,</span> <span class="token keyword keyword-char">char</span> <span class="token operator">*</span>dst<span class="token punctuation">,</span> uint64 srcva<span class="token punctuation">,</span> uint64 max<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
<span class="token keyword keyword-return">return</span> <span class="token function">copyinstr_new</span><span class="token punctuation">(</span>pagetable <span class="token punctuation">,</span> dst <span class="token punctuation">,</span> srcva <span class="token punctuation">,</span> max<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><p>在kernel/vm.c中新增函数，并在kernel/defs.h中声明：</p>
<pre data-role="codeBlock" data-info="c" class="language-c c"><code><span class="token keyword keyword-void">void</span>
<span class="token function">u2kcopy</span><span class="token punctuation">(</span><span class="token class-name">pagetable_t</span> u<span class="token punctuation">,</span> <span class="token class-name">pagetable_t</span> k<span class="token punctuation">,</span> uint64 bz<span class="token punctuation">,</span> uint64 sz<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
<span class="token comment">// 把用户页表u从起始位置bz到终止位置sz复制到内核页表k中</span>

<span class="token comment">// 这个函数是仿照uvmcopy实现的，但是做了修改！！</span>
<span class="token comment">// 实际上原理很简单，就是通过用户页表先找到物理页</span>
<span class="token comment">// 然后再为内核页表的相同虚拟地址添加到这个物理页的映射即可</span>

<span class="token comment">// 但是按照uvmcopy中的实现，直接使用mappages会出很多问题，其原因在于mappages中做了很多检查</span>

<span class="token comment">// 首先，如果原虚拟地址存在映射，会触发"panic:remap"</span>
<span class="token comment">// 这实际上是题目中的坑点,因为本身能使用这个simplify需要满足内核和用户的虚拟地址是不重合的</span>
<span class="token comment">// 但实际上，会重合，因为在题目所说的PLIC下方，内核里其实有东西</span>
<span class="token comment">// 只不过它不会在进程的内核中被使用，因此覆盖这个映射本身没问题，但是使用mappages的话会触发这个panic</span>
<span class="token comment">// 解决方法是直接在vm.c中搜索"remap"，把触发的那两行注释掉</span>

<span class="token comment">// 第二，不要随便删除判断条件，一定要加上判断条件！！</span>
<span class="token comment">// 在这里我被坑了很久，因为原先没有判断if((*pte &amp; PTE_V) == 0)</span>
<span class="token comment">// 这会导致始终无法通过validatestest这个测试</span>
<span class="token comment">// 这个测试会试图传入无效的用户虚拟地址，以达到让内核崩溃的目的</span>
<span class="token comment">// 实际上，就算我们原原本本的把假的虚拟地址对应的PTE复制到内核中，也不会出问题</span>
<span class="token comment">// 因为使用这个假的PTE的时候，会发现它的标志位显示PTE_V是不可用的</span>
<span class="token comment">// 这么做顶多就是浪费，并不会导致出错</span>
<span class="token comment">// 真正致命的点在于，在mappages中，会自动把PTE_V设置为真</span>
<span class="token comment">// 因为mappages本意就是添加一个映射，并把它置为合法的，而我们想实现的是拷贝一个合法的映射，这是不一样的</span>

<span class="token class-name">pte_t</span> <span class="token operator">*</span>pte  <span class="token punctuation">;</span>
uint64  pa <span class="token punctuation">,</span> va<span class="token punctuation">;</span>
uint flags<span class="token punctuation">;</span>

bz <span class="token operator">=</span> <span class="token function">PGROUNDUP</span><span class="token punctuation">(</span>bz<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword keyword-for">for</span><span class="token punctuation">(</span>va <span class="token operator">=</span> bz<span class="token punctuation">;</span> va <span class="token operator">&lt;</span> sz<span class="token punctuation">;</span> va <span class="token operator">+=</span> PGSIZE<span class="token punctuation">)</span><span class="token punctuation">{</span>

  pte <span class="token operator">=</span> <span class="token function">walk</span><span class="token punctuation">(</span>u<span class="token punctuation">,</span> va<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

  <span class="token keyword keyword-if">if</span><span class="token punctuation">(</span><span class="token punctuation">(</span>pte <span class="token operator">=</span> <span class="token function">walk</span><span class="token punctuation">(</span>old<span class="token punctuation">,</span> i<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span>
    <span class="token function">panic</span><span class="token punctuation">(</span><span class="token string">"uvmcopy: pte should exist"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword keyword-if">if</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token operator">*</span>pte <span class="token operator">&amp;</span> PTE_V<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span>
    <span class="token function">panic</span><span class="token punctuation">(</span><span class="token string">"uvmcopy: page not present"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  
  flags <span class="token operator">=</span> <span class="token function">PTE_FLAGS</span><span class="token punctuation">(</span><span class="token operator">*</span>pte<span class="token punctuation">)</span><span class="token punctuation">;</span>
  pa <span class="token operator">=</span> <span class="token function">PTE2PA</span><span class="token punctuation">(</span><span class="token operator">*</span>pte<span class="token punctuation">)</span><span class="token punctuation">;</span>  
  <span class="token comment">// 这里要修改关于PTE_U的权限</span>
  flags <span class="token operator">=</span> flags <span class="token operator">&amp;</span><span class="token punctuation">(</span><span class="token operator">~</span>PTE_U<span class="token punctuation">)</span><span class="token punctuation">;</span>
  
  <span class="token function">mappages</span><span class="token punctuation">(</span>k <span class="token punctuation">,</span> va <span class="token punctuation">,</span> PGSIZE <span class="token punctuation">,</span> pa <span class="token punctuation">,</span> flags<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><p>剩下的步骤就简单了，只需要在每次用户页表发生变化的时候，同步到内核页表即可；<br>
这里需要注意的是，进程的内核页表和用户页表的诞生时间是不一样的；<br>
一旦进程被分配，它的内核页表就已经被设置好了，而用户页表此时还是空的，需要按照需求设置。<br>
在kernel/proc.c中做如下修改：</p>
<pre data-role="codeBlock" data-info="c" class="language-c c"><code><span class="token comment">// userinit函数中添加</span>
<span class="token function">u2kcopy</span><span class="token punctuation">(</span>p<span class="token operator">-&gt;</span>pagetable <span class="token punctuation">,</span> p<span class="token operator">-&gt;</span>kpt <span class="token punctuation">,</span> <span class="token number">0</span> <span class="token punctuation">,</span> p<span class="token operator">-&gt;</span>sz<span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">// growproc函数中添加，这个函数是系统调用sbrk需要使用的</span>
<span class="token keyword keyword-if">if</span><span class="token punctuation">(</span>n <span class="token operator">&gt;</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
<span class="token keyword keyword-if">if</span><span class="token punctuation">(</span>sz <span class="token operator">+</span>  n <span class="token operator">&gt;=</span> PLIC<span class="token punctuation">)</span><span class="token punctuation">{</span>
  <span class="token keyword keyword-return">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token keyword keyword-if">if</span><span class="token punctuation">(</span><span class="token punctuation">(</span>sz <span class="token operator">=</span> <span class="token function">uvmalloc</span><span class="token punctuation">(</span>p<span class="token operator">-&gt;</span>pagetable<span class="token punctuation">,</span> sz<span class="token punctuation">,</span> sz <span class="token operator">+</span> n<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword keyword-return">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token function">u2kcopy</span><span class="token punctuation">(</span>p<span class="token operator">-&gt;</span>pagetable <span class="token punctuation">,</span> p<span class="token operator">-&gt;</span>kpt <span class="token punctuation">,</span> p<span class="token operator">-&gt;</span>sz <span class="token punctuation">,</span> sz<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span> <span class="token keyword keyword-else">else</span> <span class="token keyword keyword-if">if</span><span class="token punctuation">(</span>n <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
sz <span class="token operator">=</span> <span class="token function">uvmdealloc</span><span class="token punctuation">(</span>p<span class="token operator">-&gt;</span>pagetable<span class="token punctuation">,</span> sz<span class="token punctuation">,</span> sz <span class="token operator">+</span> n<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token comment">// fork函数中添加</span>
<span class="token function">u2kcopy</span><span class="token punctuation">(</span>np<span class="token operator">-&gt;</span>pagetable <span class="token punctuation">,</span> np<span class="token operator">-&gt;</span>kpt <span class="token punctuation">,</span>  <span class="token number">0</span> <span class="token punctuation">,</span> np<span class="token operator">-&gt;</span>sz<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><p>在kernel/exec.c中添加：</p>
<pre data-role="codeBlock" data-info="c" class="language-c c"><code>uint64 sz1<span class="token punctuation">;</span>
<span class="token keyword keyword-if">if</span><span class="token punctuation">(</span><span class="token punctuation">(</span>sz1 <span class="token operator">=</span> <span class="token function">uvmalloc</span><span class="token punctuation">(</span>pagetable<span class="token punctuation">,</span> sz<span class="token punctuation">,</span> ph<span class="token punctuation">.</span>vaddr <span class="token operator">+</span> ph<span class="token punctuation">.</span>memsz<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span>
<span class="token keyword keyword-goto">goto</span> bad<span class="token punctuation">;</span>
<span class="token comment">// 确保不会超过范围</span>
<span class="token keyword keyword-if">if</span><span class="token punctuation">(</span>sz1 <span class="token operator">&gt;=</span> PLIC<span class="token punctuation">)</span>
  <span class="token keyword keyword-goto">goto</span> bad<span class="token punctuation">;</span>


<span class="token comment">// 在最后添加</span>
<span class="token function">u2kcopy</span><span class="token punctuation">(</span>p<span class="token operator">-&gt;</span>pagetable <span class="token punctuation">,</span> p<span class="token operator">-&gt;</span>kpt <span class="token punctuation">,</span>  <span class="token number">0</span> <span class="token punctuation">,</span> p<span class="token operator">-&gt;</span>sz<span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">// 打印第一个进程的页表</span>
<span class="token keyword keyword-if">if</span><span class="token punctuation">(</span>p<span class="token operator">-&gt;</span>pid <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">)</span>
<span class="token function">vmprint</span><span class="token punctuation">(</span>p<span class="token operator">-&gt;</span>pagetable<span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token keyword keyword-return">return</span> argc<span class="token punctuation">;</span> <span class="token comment">// this ends up in a0, the first argument to main(argc, argv)</span>
</code></pre></details>
<h1 id="lec5">LEC5 </h1>
<h2 id="汇编语言">汇编语言 </h2>
<p>C语言需要先翻译给成汇编语言，处理器只能处理汇编语言；<br>
本课程的实验使用的是RISC-V，和通常的x86有所不同；<br>
RISC-V的指令数量显著少于x86；<br>
RISC-V的指令的复杂度更低；</p>
<h2 id="risc-v寄存器">RISC-V寄存器 </h2>
<p><img src="..\assets\images\s.6081\image-8.png" alt="alt text"><br>
汇编代码不是在内存上执行，而是在寄存器上执行；<br>
引用寄存器时，使用它的ABI名字；</p>
<p>a0-a7寄存器存储函数的参数，一个函数如果有超过8个参数，就需要使用内存；</p>
<p>callee和caller的区别在于，在函数调用时是否被保存；<br>
不保存意味着，调用的函数可以重新寄存器里面的值；<br>
举例来说，ra寄存器是caller寄存器；<br>
当函数a调用函数b时，会重写ra寄存器中的数值；</p>
<p>寄存器的长度都是64位，如果不足会在前方补（0或符号）；<br>
如果想存128位的数，需要一对寄存器共同存储。</p>
<h2 id="栈">栈 </h2>
<p>每调用一个函数，函数会创建一个栈给自己用；<br>
通过栈的指针来完成空间分配，栈总是向下增长，因此分配空间是栈指针做减法；<br>
<img src="..\assets\images\s.6081\image-9.png" alt="alt text"></p>
<p>栈中最开始会存储返回地址，也就是函数执行完之后的下一个指令地址；<br>
并在固定位置存储指向前一个栈的地址，这是为了能够使用前一个函数中的局部变量和参数；</p>
<p>在汇编代码中，函数总是先有序言prologue，然后是函数体，最后是尾声epilogue:<br>
<img src="..\assets\images\s.6081\image-10.png" alt="alt text"><br>
在sum_then_double函数中，先进行的是移动指针sp -= 16;<br>
这是为了给当前步的存储预留空间；<br>
标准是16字节,但是实际上我们这里只存了ra中保存的返回地址的8字节，并没有存前一个栈的地址；<br>
然后调用子函数sum_to；<br>
在子函数完成之后，此时ra里面放的是sum_to的返回地址；<br>
因此我们要先把之前放在0(sp)里面的sum_then_double返回地址取出来，放到ra中；<br>
最后再sp += 16，退出函数，返回原来的指针。</p>
<h1 id="lec6">LEC6 </h1>
<h2 id="trap机制">trap机制 </h2>
<p>用户空间和内核空间的切换称为trap；<br>
遇到如下情况时会面临这种切换：<br>
执行系统调用；<br>
出现错误，比如page fault等；<br>
出现中断，硬件触发相应请求，用户无权处理；</p>
<p>我们知道用户可以操作32个寄存器，这些寄存器反映了当前的执行状态；<br>
一旦开始trap，我们就得准备交给内核管理；<br>
注意到trap机制对于用户而言是透明的，即用户并不知道切入内核以后的任何事情，因此我们需要把当前的寄存器全部保存下来，方便trap退出后恢复；<br>
需要注意的是，一些寄存器存储了当前的模式权限，比如说之前遇到的satp寄存器中存放的是用户页表或者内核页表；<br>
还有mode寄存器可以决定现在是用户模式还是内核模式；</p>
<p>因此trap在进入内核之前，会保存之前的寄存器状态，并修改部分寄存器的状态。</p>
<h2 id="trap过程">trap过程 </h2>
<p>我们以最简单的shell为例，来讲解trap过程；<br>
shell本身是一个用户程序，它会打印一个“$”到控制器中，这需要用到系统调用write；<br>
因此这中间涉及到trap过程，我们具体解析；</p>
<p>这个系统调用会触发<code>ecall</code>，我们具体分析这一步会发生什么；<br>
它将代码从user mode改成了supervisor mode;<br>
将程序计数器pc保存到了sepc寄存器中；<br>
进入到stvec寄存器指向的指令，也就是pc变到了新的地址；<br>
这里可以看到，pc从一个低地址变到了高地址，也就是进入了前面提到过的tramponline page；</p>
<p>顺便一提，跟着课程操作的话，si并不能进入<code>ecall</code>内部，而是把它当作一个命令处理；</p>
<p><code>ecall</code>只完成了以上三件事，我们需要先把当前32个寄存器保存下来，否则由于我们做任何事都会用到寄存器，也就把之前的内容覆盖掉了；<br>
下面，将进入<code>uservec</code>函数，这是一段汇编代码的函数：<br>
寄存器保存在trapframe page之中，每个用户页表中都包含这个页在其顶端；<br>
不过我们仍需知道trapframe page的起始虚拟地址，它被保存再来sscratch寄存器中；<br>
由于trapframe page的起始虚拟地址总是固定的，每当程序进入用户模式时，就会为sscratch寄存器中保存这个虚拟地址；</p>
<p>接着会执行一个交换寄存器内容的指令，把a0寄存器和sscratch寄存器交换，于是就可以把剩下的寄存器的值保存到相当a0一定偏移的地址中了，它们都处于trapframe page；</p>
<p>trapframe page一方面用来存当前寄存器的值，其中本身也存了一些重要的数据，接下来就是要把这些数据放到寄存器中；<br>
sp寄存器放入当前进程的内核栈指针；<br>
tp寄存器放入当前在那个cpu核上处理；<br>
t0寄存器放入要执行的第一个C函数的指针，也就是<code>usertrap</code>指针；<br>
t1寄存器放入的是内核页表，接下来再把t1寄存器和satp寄存器交换；</p>
<p>注意这里我们切换了页表，但是程序并没有崩溃，是因为我们现在处在tramponline page的代码中；<br>
而内核和用户的虚拟地址顶端的tramponline代码映射到了完全相同的物理地址上；<br>
完成了以上步骤之后，我们就会跳转到内核的C代码中，即t0指向的<code>usertrap</code>函数；</p>
<p>我们首先得知道当前运行的进程p；<br>
然后把仍然保存在SEPC寄存器中的用户程序计数器保存到进程p-&gt;trapframe-&gt;epc中；<br>
接下来要找到触发trap的原因，它被存在scause寄存器中；<br>
如果当前进程没有被杀死，我们退出的位置应该是SEPC寄存器中的那个指令的下一条指令，因此进行更改；</p>
<p>接下来执行对应的sys_call，执行的系统调用编号存在p-&gt;trapframe-&gt;a7中；<br>
而这个系统调用所需要的参数也就是<code>write(2 , "$ " , 2)</code>中的2,"$ ",2；<br>
它们被保存在p-&gt;trapframe-&gt;a0 ,p-&gt;trapframe-&gt;a1 ,p-&gt;trapframe-&gt;a2中；<br>
注意，要把系统调用的返回值重新传回到p-&gt;trapframe-&gt;a0中；<br>
因此返回到用户空间后，把trapframe中的a0写入到a0寄存器中，就可以得到系统调用的返回值；</p>
<p>如果进程没有被杀掉，在<code>usertrap</code>函数的最后进入<code>usertrapret</code>函数；</p>
<p>首先设置stvec寄存器指向tramponline代码，以便下一次使用；<br>
接下来要网trapframe中填入：<br>
内核页表、内核栈、usertrap函数的指针、cpu核编号，这些都是为了下一次trap做准备；</p>
<p>接下来修改sstatus寄存器，这个寄存器中的数值的某些位控制了模式切换核中断设置；<br>
然后把p-&gt;trapframe-&gt;epc中的值填回到sepc寄存器中；<br>
根据用户页表的地址生成相应的satp值，注意这一步只能在汇编代码中完成；<br>
因此我们需要取出这一段汇编代码的地址，也就是<code>userret</code>函数；</p>
<p>首先把之前的生成的satp值存入satp寄存器中；<br>
下面要逐步把寄存器中的内核内容，修改为之前保存在trapframe中的用户寄存器的内容；<br>
注意此时的a0寄存器中是trapframe的位置；<br>
首先把sscratch寄存器恢复成用户的a0寄存器；<br>
接下来把trapframe中的值依次填回到寄存器中；<br>
注意这时a0寄存器是trapframe的位置，sscratch寄存器中是用户的a0寄存器，需要把它们交换回来；<br>
完成这些操作以后，执行sret指令；</p>
<p>这条指令会切换回用户模式；<br>
把sepc寄存器放入到pc寄存器中，并重新打开中断；<br>
此时我们已经回到了用户空间，并且寄存器内容和进入trap之前是一样的。</p>
<h2 id="lab4--traps">Lab4 : traps </h2>
<p>点击可以展开以下使用的代码实现：</p>
<details>
<summary>backtrace</summary>
<p>在kernel/riscv.h中添加如下代码：</p>
<pre data-role="codeBlock" data-info="c" class="language-c c"><code><span class="token keyword keyword-static">static</span> <span class="token keyword keyword-inline">inline</span> uint64
<span class="token function">r_fp</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
uint64 x<span class="token punctuation">;</span>
<span class="token keyword keyword-asm">asm</span> <span class="token keyword keyword-volatile">volatile</span><span class="token punctuation">(</span><span class="token string">"mv %0, s0"</span> <span class="token operator">:</span> <span class="token string">"=r"</span> <span class="token punctuation">(</span>x<span class="token punctuation">)</span> <span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword keyword-return">return</span> x<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><p>在kernel/printf.c中添加如下函数，并在kernel/defs.h中声明：</p>
<pre data-role="codeBlock" data-info="c" class="language-c c"><code><span class="token keyword keyword-void">void</span>
<span class="token function">backtrace</span><span class="token punctuation">(</span><span class="token keyword keyword-void">void</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
uint64 fp <span class="token punctuation">,</span> top <span class="token punctuation">,</span> bottom <span class="token punctuation">,</span> ra<span class="token punctuation">;</span>
<span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"backtrace:\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

fp <span class="token operator">=</span> <span class="token function">r_fp</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// 栈帧的移动不能超出预定范围</span>
top <span class="token operator">=</span> <span class="token function">PGROUNDUP</span><span class="token punctuation">(</span>fp<span class="token punctuation">)</span><span class="token punctuation">;</span>
bottom <span class="token operator">=</span> <span class="token function">PGROUNDDOWN</span><span class="token punctuation">(</span>fp<span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token keyword keyword-while">while</span><span class="token punctuation">(</span>fp <span class="token operator">&lt;</span> top <span class="token operator">&amp;&amp;</span> fp <span class="token operator">&gt;</span> bottom<span class="token punctuation">)</span><span class="token punctuation">{</span>
  ra <span class="token operator">=</span> <span class="token operator">*</span><span class="token punctuation">(</span>uint64 <span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">(</span>fp <span class="token operator">-</span> <span class="token number">8</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 返回地址</span>
  <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%p\n"</span> <span class="token punctuation">,</span> ra<span class="token punctuation">)</span><span class="token punctuation">;</span>
  fp <span class="token operator">=</span> <span class="token operator">*</span><span class="token punctuation">(</span>uint64 <span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">(</span>fp <span class="token operator">-</span> <span class="token number">16</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 前一个栈帧的地址</span>
<span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><p>在kernel/sysproc.c中的sys_sleep函数中调用backtrace:</p>
<pre data-role="codeBlock" data-info="c" class="language-c c"><code>int64
<span class="token function">sys_sleep</span><span class="token punctuation">(</span><span class="token keyword keyword-void">void</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
<span class="token function">backtrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">/*
.....
*/</span>
<span class="token punctuation">}</span>
</code></pre></details>
<details>
<summary>alarm</summary>
<p>在Makefile中添加alarmtest，在user/user.h和user/usys.pl中声明系统调用<code>sigalarm</code>和<code>sigreturn</code>；<br>
在kernel/syscall.h和kernel/syscall.c中声明系统调用；</p>
<p>在kernel/proc.h的proc结构体中添加以下变量：</p>
<pre data-role="codeBlock" data-info="c" class="language-c c"><code><span class="token keyword keyword-int">int</span> ticks<span class="token punctuation">;</span> 
<span class="token keyword keyword-void">void</span> <span class="token punctuation">(</span><span class="token operator">*</span>handler<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword keyword-int">int</span> tick_tick<span class="token punctuation">;</span> <span class="token comment">// 当前进程的tick数</span>
<span class="token keyword keyword-int">int</span> in_handler<span class="token punctuation">;</span> <span class="token comment">// 是否已经在handler中</span>

<span class="token comment">// 保存trapframe中的寄存器，在完成handler之后归还</span>
uint64 save_epc<span class="token punctuation">;</span>           
uint64 save_ra<span class="token punctuation">;</span>
uint64 save_sp<span class="token punctuation">;</span>
uint64 save_gp<span class="token punctuation">;</span>
uint64 save_tp<span class="token punctuation">;</span>
uint64 save_t0<span class="token punctuation">;</span>
uint64 save_t1<span class="token punctuation">;</span>
uint64 save_t2<span class="token punctuation">;</span>
uint64 save_s0<span class="token punctuation">;</span>
uint64 save_s1<span class="token punctuation">;</span>
uint64 save_a0<span class="token punctuation">;</span>
uint64 save_a1<span class="token punctuation">;</span>
uint64 save_a2<span class="token punctuation">;</span>
uint64 save_a3<span class="token punctuation">;</span>
uint64 save_a4<span class="token punctuation">;</span>
uint64 save_a5<span class="token punctuation">;</span>
uint64 save_a6<span class="token punctuation">;</span>
uint64 save_a7<span class="token punctuation">;</span>
uint64 save_s2<span class="token punctuation">;</span>
uint64 save_s3<span class="token punctuation">;</span>
uint64 save_s4<span class="token punctuation">;</span>
uint64 save_s5<span class="token punctuation">;</span>
uint64 save_s6<span class="token punctuation">;</span>
uint64 save_s7<span class="token punctuation">;</span>
uint64 save_s8<span class="token punctuation">;</span>
uint64 save_s9<span class="token punctuation">;</span>
uint64 save_s10<span class="token punctuation">;</span>
uint64 save_s11<span class="token punctuation">;</span>
uint64 save_t3<span class="token punctuation">;</span>
uint64 save_t4<span class="token punctuation">;</span>
uint64 save_t5<span class="token punctuation">;</span>
uint64 save_t6<span class="token punctuation">;</span>
</code></pre><p>在kernel/sysfile.c中完成系统调用函数：</p>
<pre data-role="codeBlock" data-info="c" class="language-c c"><code>uint64
<span class="token function">sys_sigalarm</span><span class="token punctuation">(</span><span class="token keyword keyword-void">void</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
<span class="token comment">// 把传入的参数保存到proc结构体中</span>
<span class="token keyword keyword-struct">struct</span> <span class="token class-name">proc</span> <span class="token operator">*</span>p <span class="token operator">=</span> <span class="token function">myproc</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword keyword-int">int</span> ticks<span class="token punctuation">;</span>
uint64 handler<span class="token punctuation">;</span>

<span class="token keyword keyword-if">if</span><span class="token punctuation">(</span><span class="token function">argint</span><span class="token punctuation">(</span><span class="token number">0</span> <span class="token punctuation">,</span> <span class="token operator">&amp;</span>ticks<span class="token punctuation">)</span> <span class="token operator">&lt;</span> <span class="token number">0</span> <span class="token operator">||</span> <span class="token function">argaddr</span><span class="token punctuation">(</span><span class="token number">1</span> <span class="token punctuation">,</span> <span class="token operator">&amp;</span>handler<span class="token punctuation">)</span> <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span>
  <span class="token keyword keyword-return">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>

p <span class="token operator">-&gt;</span> ticks <span class="token operator">=</span> ticks<span class="token punctuation">;</span>
p <span class="token operator">-&gt;</span> handler <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword keyword-void">void</span><span class="token punctuation">(</span><span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>handler<span class="token punctuation">;</span>
<span class="token keyword keyword-return">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

uint64
<span class="token function">sys_sigreturn</span><span class="token punctuation">(</span><span class="token keyword keyword-void">void</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
<span class="token comment">// 把proc结构体中的寄存器归还给trapframe页</span>
<span class="token keyword keyword-struct">struct</span> <span class="token class-name">proc</span> <span class="token operator">*</span>p <span class="token operator">=</span> <span class="token function">myproc</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

p<span class="token operator">-&gt;</span>trapframe<span class="token operator">-&gt;</span>epc <span class="token operator">=</span> p<span class="token operator">-&gt;</span>save_epc<span class="token punctuation">;</span>           
p<span class="token operator">-&gt;</span>trapframe<span class="token operator">-&gt;</span>ra <span class="token operator">=</span> p<span class="token operator">-&gt;</span>save_ra<span class="token punctuation">;</span>
p<span class="token operator">-&gt;</span>trapframe<span class="token operator">-&gt;</span>sp <span class="token operator">=</span> p<span class="token operator">-&gt;</span>save_sp<span class="token punctuation">;</span>
p<span class="token operator">-&gt;</span>trapframe<span class="token operator">-&gt;</span>gp <span class="token operator">=</span> p<span class="token operator">-&gt;</span>save_gp<span class="token punctuation">;</span>
p<span class="token operator">-&gt;</span>trapframe<span class="token operator">-&gt;</span>tp <span class="token operator">=</span> p<span class="token operator">-&gt;</span>save_tp<span class="token punctuation">;</span>
p<span class="token operator">-&gt;</span>trapframe<span class="token operator">-&gt;</span>t0 <span class="token operator">=</span> p<span class="token operator">-&gt;</span>save_t0<span class="token punctuation">;</span>
p<span class="token operator">-&gt;</span>trapframe<span class="token operator">-&gt;</span>t1 <span class="token operator">=</span> p<span class="token operator">-&gt;</span>save_t1<span class="token punctuation">;</span>
p<span class="token operator">-&gt;</span>trapframe<span class="token operator">-&gt;</span>t2 <span class="token operator">=</span> p<span class="token operator">-&gt;</span>save_t2<span class="token punctuation">;</span>
p<span class="token operator">-&gt;</span>trapframe<span class="token operator">-&gt;</span>s0 <span class="token operator">=</span> p<span class="token operator">-&gt;</span>save_s0<span class="token punctuation">;</span>
p<span class="token operator">-&gt;</span>trapframe<span class="token operator">-&gt;</span>s1 <span class="token operator">=</span> p<span class="token operator">-&gt;</span>save_s1<span class="token punctuation">;</span>
p<span class="token operator">-&gt;</span>trapframe<span class="token operator">-&gt;</span>a0 <span class="token operator">=</span> p<span class="token operator">-&gt;</span>save_a0<span class="token punctuation">;</span>
p<span class="token operator">-&gt;</span>trapframe<span class="token operator">-&gt;</span>a1 <span class="token operator">=</span> p<span class="token operator">-&gt;</span>save_a1<span class="token punctuation">;</span>
p<span class="token operator">-&gt;</span>trapframe<span class="token operator">-&gt;</span>a2 <span class="token operator">=</span> p<span class="token operator">-&gt;</span>save_a2<span class="token punctuation">;</span>
p<span class="token operator">-&gt;</span>trapframe<span class="token operator">-&gt;</span>a3 <span class="token operator">=</span> p<span class="token operator">-&gt;</span>save_a3<span class="token punctuation">;</span>
p<span class="token operator">-&gt;</span>trapframe<span class="token operator">-&gt;</span>a4 <span class="token operator">=</span> p<span class="token operator">-&gt;</span>save_a4<span class="token punctuation">;</span>
p<span class="token operator">-&gt;</span>trapframe<span class="token operator">-&gt;</span>a5 <span class="token operator">=</span> p<span class="token operator">-&gt;</span>save_a5<span class="token punctuation">;</span>
p<span class="token operator">-&gt;</span>trapframe<span class="token operator">-&gt;</span>a6 <span class="token operator">=</span> p<span class="token operator">-&gt;</span>save_a6<span class="token punctuation">;</span>
p<span class="token operator">-&gt;</span>trapframe<span class="token operator">-&gt;</span>a7 <span class="token operator">=</span> p<span class="token operator">-&gt;</span>save_a7<span class="token punctuation">;</span>
p<span class="token operator">-&gt;</span>trapframe<span class="token operator">-&gt;</span>s2 <span class="token operator">=</span> p<span class="token operator">-&gt;</span>save_s2<span class="token punctuation">;</span>
p<span class="token operator">-&gt;</span>trapframe<span class="token operator">-&gt;</span>s3 <span class="token operator">=</span> p<span class="token operator">-&gt;</span>save_s3<span class="token punctuation">;</span>
p<span class="token operator">-&gt;</span>trapframe<span class="token operator">-&gt;</span>s4 <span class="token operator">=</span> p<span class="token operator">-&gt;</span>save_s4<span class="token punctuation">;</span>
p<span class="token operator">-&gt;</span>trapframe<span class="token operator">-&gt;</span>s5 <span class="token operator">=</span> p<span class="token operator">-&gt;</span>save_s5<span class="token punctuation">;</span>
p<span class="token operator">-&gt;</span>trapframe<span class="token operator">-&gt;</span>s6 <span class="token operator">=</span> p<span class="token operator">-&gt;</span>save_s6<span class="token punctuation">;</span>
p<span class="token operator">-&gt;</span>trapframe<span class="token operator">-&gt;</span>s7 <span class="token operator">=</span> p<span class="token operator">-&gt;</span>save_s7<span class="token punctuation">;</span>
p<span class="token operator">-&gt;</span>trapframe<span class="token operator">-&gt;</span>s8 <span class="token operator">=</span> p<span class="token operator">-&gt;</span>save_s8<span class="token punctuation">;</span>
p<span class="token operator">-&gt;</span>trapframe<span class="token operator">-&gt;</span>s9 <span class="token operator">=</span> p<span class="token operator">-&gt;</span>save_s9<span class="token punctuation">;</span>
p<span class="token operator">-&gt;</span>trapframe<span class="token operator">-&gt;</span>s10 <span class="token operator">=</span> p<span class="token operator">-&gt;</span>save_s10<span class="token punctuation">;</span>
p<span class="token operator">-&gt;</span>trapframe<span class="token operator">-&gt;</span>s11 <span class="token operator">=</span> p<span class="token operator">-&gt;</span>save_s11<span class="token punctuation">;</span>
p<span class="token operator">-&gt;</span>trapframe<span class="token operator">-&gt;</span>t3 <span class="token operator">=</span> p<span class="token operator">-&gt;</span>save_t3<span class="token punctuation">;</span>
p<span class="token operator">-&gt;</span>trapframe<span class="token operator">-&gt;</span>t4 <span class="token operator">=</span> p<span class="token operator">-&gt;</span>save_t4<span class="token punctuation">;</span>
p<span class="token operator">-&gt;</span>trapframe<span class="token operator">-&gt;</span>t5 <span class="token operator">=</span> p<span class="token operator">-&gt;</span>save_t5<span class="token punctuation">;</span>
p<span class="token operator">-&gt;</span>trapframe<span class="token operator">-&gt;</span>t6 <span class="token operator">=</span> p<span class="token operator">-&gt;</span>save_t6<span class="token punctuation">;</span>

<span class="token comment">// 退出handler标记</span>
p<span class="token operator">-&gt;</span>in_handler <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>

<span class="token keyword keyword-return">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><p>在kernel/trap.c的中断处理部分添加：</p>
<pre data-role="codeBlock" data-info="c" class="language-c c"><code><span class="token keyword keyword-else">else</span> <span class="token keyword keyword-if">if</span><span class="token punctuation">(</span><span class="token punctuation">(</span>which_dev <span class="token operator">=</span> <span class="token function">devintr</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
  <span class="token comment">// ok</span>
  <span class="token comment">// 这里处理设备中断</span>
  <span class="token keyword keyword-if">if</span><span class="token punctuation">(</span>which_dev <span class="token operator">==</span> <span class="token number">2</span> <span class="token operator">&amp;&amp;</span> p<span class="token operator">-&gt;</span>in_handler <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    p<span class="token operator">-&gt;</span>tick_tick <span class="token operator">+=</span> <span class="token number">1</span><span class="token punctuation">;</span>
    <span class="token keyword keyword-if">if</span><span class="token punctuation">(</span><span class="token punctuation">(</span>p<span class="token operator">-&gt;</span>tick_tick <span class="token operator">==</span> p<span class="token operator">-&gt;</span>ticks<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> <span class="token punctuation">(</span>p<span class="token operator">-&gt;</span>ticks <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span>

      <span class="token comment">// 把trapframe页中的寄存器内容保存下来</span>
      p<span class="token operator">-&gt;</span>save_epc <span class="token operator">=</span> p<span class="token operator">-&gt;</span>trapframe<span class="token operator">-&gt;</span>epc<span class="token punctuation">;</span>           
      p<span class="token operator">-&gt;</span>save_ra <span class="token operator">=</span> p<span class="token operator">-&gt;</span>trapframe<span class="token operator">-&gt;</span>ra<span class="token punctuation">;</span>
      p<span class="token operator">-&gt;</span>save_sp <span class="token operator">=</span> p<span class="token operator">-&gt;</span>trapframe<span class="token operator">-&gt;</span>sp<span class="token punctuation">;</span>
      p<span class="token operator">-&gt;</span>save_gp <span class="token operator">=</span> p<span class="token operator">-&gt;</span>trapframe<span class="token operator">-&gt;</span>gp<span class="token punctuation">;</span>
      p<span class="token operator">-&gt;</span>save_tp <span class="token operator">=</span> p<span class="token operator">-&gt;</span>trapframe<span class="token operator">-&gt;</span>tp<span class="token punctuation">;</span>
      p<span class="token operator">-&gt;</span>save_t0 <span class="token operator">=</span> p<span class="token operator">-&gt;</span>trapframe<span class="token operator">-&gt;</span>t0<span class="token punctuation">;</span>
      p<span class="token operator">-&gt;</span>save_t1 <span class="token operator">=</span> p<span class="token operator">-&gt;</span>trapframe<span class="token operator">-&gt;</span>t1<span class="token punctuation">;</span>
      p<span class="token operator">-&gt;</span>save_t2 <span class="token operator">=</span> p<span class="token operator">-&gt;</span>trapframe<span class="token operator">-&gt;</span>t2<span class="token punctuation">;</span>
      p<span class="token operator">-&gt;</span>save_s0 <span class="token operator">=</span> p<span class="token operator">-&gt;</span>trapframe<span class="token operator">-&gt;</span>s0<span class="token punctuation">;</span>
      p<span class="token operator">-&gt;</span>save_s1 <span class="token operator">=</span> p<span class="token operator">-&gt;</span>trapframe<span class="token operator">-&gt;</span>s1<span class="token punctuation">;</span>
      p<span class="token operator">-&gt;</span>save_a0 <span class="token operator">=</span> p<span class="token operator">-&gt;</span>trapframe<span class="token operator">-&gt;</span>a0<span class="token punctuation">;</span>
      p<span class="token operator">-&gt;</span>save_a1 <span class="token operator">=</span> p<span class="token operator">-&gt;</span>trapframe<span class="token operator">-&gt;</span>a1<span class="token punctuation">;</span>
      p<span class="token operator">-&gt;</span>save_a2 <span class="token operator">=</span> p<span class="token operator">-&gt;</span>trapframe<span class="token operator">-&gt;</span>a2<span class="token punctuation">;</span>
      p<span class="token operator">-&gt;</span>save_a3 <span class="token operator">=</span> p<span class="token operator">-&gt;</span>trapframe<span class="token operator">-&gt;</span>a3<span class="token punctuation">;</span>
      p<span class="token operator">-&gt;</span>save_a4 <span class="token operator">=</span> p<span class="token operator">-&gt;</span>trapframe<span class="token operator">-&gt;</span>a4<span class="token punctuation">;</span>
      p<span class="token operator">-&gt;</span>save_a5 <span class="token operator">=</span> p<span class="token operator">-&gt;</span>trapframe<span class="token operator">-&gt;</span>a5<span class="token punctuation">;</span>
      p<span class="token operator">-&gt;</span>save_a6 <span class="token operator">=</span> p<span class="token operator">-&gt;</span>trapframe<span class="token operator">-&gt;</span>a6<span class="token punctuation">;</span>
      p<span class="token operator">-&gt;</span>save_a7 <span class="token operator">=</span> p<span class="token operator">-&gt;</span>trapframe<span class="token operator">-&gt;</span>a7<span class="token punctuation">;</span>
      p<span class="token operator">-&gt;</span>save_s2 <span class="token operator">=</span> p<span class="token operator">-&gt;</span>trapframe<span class="token operator">-&gt;</span>s2<span class="token punctuation">;</span>
      p<span class="token operator">-&gt;</span>save_s3 <span class="token operator">=</span> p<span class="token operator">-&gt;</span>trapframe<span class="token operator">-&gt;</span>s3<span class="token punctuation">;</span>
      p<span class="token operator">-&gt;</span>save_s4 <span class="token operator">=</span> p<span class="token operator">-&gt;</span>trapframe<span class="token operator">-&gt;</span>s4<span class="token punctuation">;</span>
      p<span class="token operator">-&gt;</span>save_s5 <span class="token operator">=</span> p<span class="token operator">-&gt;</span>trapframe<span class="token operator">-&gt;</span>s5<span class="token punctuation">;</span>
      p<span class="token operator">-&gt;</span>save_s6 <span class="token operator">=</span> p<span class="token operator">-&gt;</span>trapframe<span class="token operator">-&gt;</span>s6<span class="token punctuation">;</span>
      p<span class="token operator">-&gt;</span>save_s7 <span class="token operator">=</span> p<span class="token operator">-&gt;</span>trapframe<span class="token operator">-&gt;</span>s7<span class="token punctuation">;</span>
      p<span class="token operator">-&gt;</span>save_s8 <span class="token operator">=</span> p<span class="token operator">-&gt;</span>trapframe<span class="token operator">-&gt;</span>s8<span class="token punctuation">;</span>
      p<span class="token operator">-&gt;</span>save_s9 <span class="token operator">=</span> p<span class="token operator">-&gt;</span>trapframe<span class="token operator">-&gt;</span>s9<span class="token punctuation">;</span>
      p<span class="token operator">-&gt;</span>save_s10 <span class="token operator">=</span> p<span class="token operator">-&gt;</span>trapframe<span class="token operator">-&gt;</span>s10<span class="token punctuation">;</span>
      p<span class="token operator">-&gt;</span>save_s11 <span class="token operator">=</span> p<span class="token operator">-&gt;</span>trapframe<span class="token operator">-&gt;</span>s11<span class="token punctuation">;</span>
      p<span class="token operator">-&gt;</span>save_t3 <span class="token operator">=</span> p<span class="token operator">-&gt;</span>trapframe<span class="token operator">-&gt;</span>t3<span class="token punctuation">;</span>
      p<span class="token operator">-&gt;</span>save_t4 <span class="token operator">=</span> p<span class="token operator">-&gt;</span>trapframe<span class="token operator">-&gt;</span>t4<span class="token punctuation">;</span>
      p<span class="token operator">-&gt;</span>save_t5 <span class="token operator">=</span> p<span class="token operator">-&gt;</span>trapframe<span class="token operator">-&gt;</span>t5<span class="token punctuation">;</span>
      p<span class="token operator">-&gt;</span>save_t6 <span class="token operator">=</span> p<span class="token operator">-&gt;</span>trapframe<span class="token operator">-&gt;</span>t6<span class="token punctuation">;</span>
      
      p<span class="token operator">-&gt;</span>in_handler <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
      p<span class="token operator">-&gt;</span>tick_tick <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
      <span class="token comment">// 跳转到handler函数的方式是把trapframe页表中原本保存下一条指令的地址改成handler的地址</span>
      p<span class="token operator">-&gt;</span>trapframe<span class="token operator">-&gt;</span>epc <span class="token operator">=</span> <span class="token punctuation">(</span>uint64<span class="token punctuation">)</span> p<span class="token operator">-&gt;</span>handler<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></details>
<h1 id="lec7">LEC7 </h1>
<h2 id="page-fault">page fault </h2>
<p>出现page fault，有三个信息有价值：<br>
引起page fault的虚拟内存地址；<br>
引起page fault的原因类型；<br>
引起page fault的程序计数器的值；</p>
<h2 id="lazy-allocation">lazy allocation </h2>
<p>先来看sbrk函数：<br>
<img src="..\assets\images\s.6081\image-11.png" alt="alt text"><br>
p-&gt;sz本身指向栈的顶端，同时也是堆的底端；<br>
sbrk函数接受一个整数，表示想要向上扩展堆的页数（也可以是负数）；<br>
一旦调用sbrk，系统会立即分配需要的物理内存，再进行映射；<br>
这种立即响应的方式，可能会浪费一些内存，因为用户总是会申请多于自身的所需的内存；</p>
<p>解决这种浪费的想法是利用lazy allocation；<br>
它的想法很简单，就是在sbrk时仅仅只是移动指针p-&gt;sz，但不分配内存；<br>
当遇到虚拟地址处在堆范围内，却没有物理地址映射时；<br>
我们不直接崩溃，而是为其分配一个物理页来重新执行指令；</p>
<p>因此我们需要重新处理崩溃机制；<br>
在usertrap中，我们之前只处理了scause=8的情况；<br>
scause中存储的是崩溃的原因，8代表用户发出系统调用；<br>
我们现在需要处理scause=15，也就是无物理地址映射的情况；<br>
只需要立即为其申请一个物理内存页，并完成映射即可；</p>
<h2 id="零填充">零填充 </h2>
<p>用户程序的地址空间通常包含text,data和BSS；<br>
其中BSS包含了未初始化或者初始化为0的那些全局变量；<br>
在初始化阶段，如果为这些值为0的变量都分配内存，会让程序启动速度变慢；<br>
因此由于这些变量都是0，我们干脆只为BSS区域分配1个全为0的物理页即可；<br>
后续当需要启用BSS中的虚拟地址时，触发page fault，我们再对应地分配物理页即可；<br>
当然，这么做会让程序的启动变快；<br>
但是会使得更新变慢，因为重新填写值需要触发page fault，这需要进到内核之中，速度是很慢的；</p>
<h2 id="写时复制">写时复制 </h2>
<p>考虑shell过程，我们是先fork了一个子进程，并在子进程中调用exec；<br>
在这个过程中，fork会复制一遍父进程的地址空间，但是exec马上就把它们丢弃了，这比较浪费；<br>
解决这个问题的方式是写时复制；</p>
<p>在fork的时候，并不为子进程分配物理页，而是将其虚拟地址映射到与父进程相同的物理页上去；<br>
当然这个时候需要处理子进程写如这些虚拟地址对应的物理页；<br>
因此我们把父子进程共同映射的那部分PTE设置为只读的；<br>
一旦发现需要写入只读的PTE，就会进入page fault；<br>
此时再把相应的物理页进行拷贝，即父子进程都有相应的物理页；<br>
并且这时要把二者的PTE权限都改成可读写的，因为现在它们只属于一个进程；</p>
<p>需要注意的是，现在物理页并不只被一个用户进程所对应；<br>
在这之前，只有tramponline page是这样，但是它们永不释放；<br>
现在我们需要释放page时，需要考虑是否还有其他进程正在引用它们；<br>
因此对于物理页，需要实现一个进程使用计数器；</p>
<h2 id="demand-paging">Demand Paging </h2>
<p>exec启动时，会立刻把text和data存入内存，但这一步操作代价高昂；<br>
实际上我们可能并不需要所有的指令，因此可以先不立即将它们放入内存；<br>
具体地，为text和data分配好虚拟地址，但是将PTE_V设置为无效的；</p>
<p>然后一旦需要用到text和data中的指令，触发page fault；<br>
此时我们需要先识别出来这些事on-demand page；<br>
然后再page fault handler中从程序文件中读取这些数据，并为其分配物理页表；<br>
之后就可以重新执行刚刚page fault时的指令；</p>
<p>需要注意的是，很有可能遇到内存被占满的问题；<br>
此时我们需要释放一些物理页，并将其写会文件中；<br>
那么应该选择哪些物理页进行释放呢？<br>
显然应该是没被访问过的，我们可以在PTE中设置access位，标记其是否被访问；<br>
此外，一个合理的优化是选择那些没被写过non-dirty的物理页释放；<br>
因为没被写过的页，和磁盘中内容一致，可以直接释放掉；<br>
dirty bit也是PTE标志位中的一个；</p>
<h2 id="memory-mapped-files">Memory Mapped Files </h2>
<p>这说的就是把文件加载到内存中，之后就可以使用内存地址来操作文件；<br>
这需要一个系统调用mmap,目的是把虚拟地址和这些文件关联起来；<br>
这里的实现方式仍然是lazy的，即不会立即将文件拷贝到内存中，而只是记录下这个PTE归属的文件描述符；<br>
一旦触发mmap中的虚拟地址，会导致page fault；<br>
在page fault处理中，再把相应的内容从文件读到内存中；</p>
<p>之后还会有unmap过程，也就是我们可能修改了文件；<br>
但是实际上我们是在内存中修改的；<br>
需要在unmap中找到那些dirty的页，并将相应修改同步到文件中；</p>
<h2 id="lab5--xv6-lazy-page-allocation">Lab5 : xv6 lazy page allocation </h2>
<p>点击可以展开以下代码：</p>
<details>
<summary>Eliminate</summary>
<p>修改kernel/sysproc.c中的sys_sbrk：</p>
<pre data-role="codeBlock" data-info="c" class="language-c c"><code>uint64
<span class="token function">sys_sbrk</span><span class="token punctuation">(</span><span class="token keyword keyword-void">void</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
<span class="token keyword keyword-int">int</span> addr<span class="token punctuation">;</span>
<span class="token keyword keyword-int">int</span> n<span class="token punctuation">;</span>

<span class="token keyword keyword-if">if</span><span class="token punctuation">(</span><span class="token function">argint</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>n<span class="token punctuation">)</span> <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span>
  <span class="token keyword keyword-return">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>
addr <span class="token operator">=</span> <span class="token function">myproc</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">-&gt;</span>sz<span class="token punctuation">;</span>

<span class="token function">myproc</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">-&gt;</span>sz <span class="token operator">+=</span> n<span class="token punctuation">;</span>
<span class="token comment">//if(growproc(n) &lt; 0)</span>
  <span class="token comment">// return -1;</span>
<span class="token keyword keyword-return">return</span> addr<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></details>
<details>
<summary>lazy allocation</summary>
<p>修改kernel/trap.c中的usertrap函数：</p>
<pre data-role="codeBlock" data-info="c" class="language-c c"><code><span class="token keyword keyword-else">else</span> <span class="token keyword keyword-if">if</span><span class="token punctuation">(</span><span class="token punctuation">(</span>which_dev <span class="token operator">=</span> <span class="token function">devintr</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
  <span class="token comment">// ok</span>
<span class="token punctuation">}</span> <span class="token keyword keyword-else">else</span> <span class="token keyword keyword-if">if</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token function">r_scause</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">13</span><span class="token punctuation">)</span> <span class="token operator">||</span> <span class="token punctuation">(</span><span class="token function">r_scause</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">15</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
  <span class="token comment">// 获取触发页错误的虚拟地址</span>
  uint64 va<span class="token punctuation">;</span>
  va <span class="token operator">=</span> <span class="token function">PGROUNDDOWN</span><span class="token punctuation">(</span><span class="token function">r_stval</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

  <span class="token comment">// 分配物理内存</span>
  <span class="token keyword keyword-char">char</span><span class="token operator">*</span> mem<span class="token punctuation">;</span>
  mem <span class="token operator">=</span> <span class="token function">kalloc</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword keyword-if">if</span><span class="token punctuation">(</span>mem <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token function">exit</span><span class="token punctuation">(</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
  <span class="token function">memset</span><span class="token punctuation">(</span>mem <span class="token punctuation">,</span> <span class="token number">0</span> <span class="token punctuation">,</span> PGSIZE<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword keyword-if">if</span><span class="token punctuation">(</span><span class="token function">mappages</span><span class="token punctuation">(</span>p<span class="token operator">-&gt;</span>pagetable<span class="token punctuation">,</span> va<span class="token punctuation">,</span> PGSIZE<span class="token punctuation">,</span> <span class="token punctuation">(</span>uint64<span class="token punctuation">)</span>mem<span class="token punctuation">,</span> PTE_W<span class="token operator">|</span>PTE_X<span class="token operator">|</span>PTE_R<span class="token operator">|</span>PTE_U<span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token function">kfree</span><span class="token punctuation">(</span>mem<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">exit</span><span class="token punctuation">(</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token keyword keyword-else">else</span> <span class="token punctuation">{</span>
  <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"usertrap(): unexpected scause %p pid=%d\n"</span><span class="token punctuation">,</span> <span class="token function">r_scause</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> p<span class="token operator">-&gt;</span>pid<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"            sepc=%p stval=%p\n"</span><span class="token punctuation">,</span> <span class="token function">r_sepc</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">r_stval</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  p<span class="token operator">-&gt;</span>killed <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><p>修改kernel/vm.c中的uvmunmap函数：</p>
<pre data-role="codeBlock" data-info="c" class="language-c c"><code><span class="token keyword keyword-if">if</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token operator">*</span>pte <span class="token operator">&amp;</span> PTE_V<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span>
    <span class="token keyword keyword-continue">continue</span><span class="token punctuation">;</span>
    <span class="token comment">// panic("uvmunmap: not mapped");</span>
  <span class="token comment">//  注意这里要continue</span>
  <span class="token comment">// 如果不判断的话，会进入后续的kfree引发panic:kfree</span>
</code></pre></details>
<details>
<summary>lazytests</summary>
<p>在kernel/sysproc.c中加入对于负参数的处理：</p>
<pre data-role="codeBlock" data-info="c" class="language-c c"><code><span class="token comment">// 传入负参数，删除即可</span>
<span class="token keyword keyword-if">if</span><span class="token punctuation">(</span>n <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
  <span class="token function">uvmdealloc</span><span class="token punctuation">(</span><span class="token function">myproc</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">-&gt;</span>pagetable<span class="token punctuation">,</span> <span class="token function">myproc</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">-&gt;</span>sz<span class="token punctuation">,</span> <span class="token function">myproc</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">-&gt;</span>sz <span class="token operator">+</span> n<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><p>在kernel/trap.c中加入判断条件：</p>
<pre data-role="codeBlock" data-info="c" class="language-c c"><code>va <span class="token operator">=</span> <span class="token function">r_stval</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  
  <span class="token keyword keyword-if">if</span><span class="token punctuation">(</span>va <span class="token operator">&gt;=</span> p<span class="token operator">-&gt;</span>sz <span class="token operator">||</span> va <span class="token operator">&lt;</span> p<span class="token operator">-&gt;</span>trapframe<span class="token operator">-&gt;</span>sp<span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token function">exit</span><span class="token punctuation">(</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>

  va <span class="token operator">=</span> <span class="token function">PGROUNDDOWN</span><span class="token punctuation">(</span>va<span class="token punctuation">)</span><span class="token punctuation">;</span>

</code></pre><p>在kernel/vm.c中处理几个读到无效物理页的情况：</p>
<pre data-role="codeBlock" data-info="c" class="language-c c"><code><span class="token comment">// uvmcopy函数</span>
<span class="token keyword keyword-if">if</span><span class="token punctuation">(</span><span class="token punctuation">(</span>pte <span class="token operator">=</span> <span class="token function">walk</span><span class="token punctuation">(</span>old<span class="token punctuation">,</span> i<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span>
    <span class="token keyword keyword-continue">continue</span><span class="token punctuation">;</span>
    <span class="token comment">// panic("uvmcopy: pte should exist");</span>
  <span class="token keyword keyword-if">if</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token operator">*</span>pte <span class="token operator">&amp;</span> PTE_V<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span>
    <span class="token keyword keyword-continue">continue</span><span class="token punctuation">;</span>
    <span class="token comment">// panic("uvmcopy: page not present");</span>

<span class="token comment">// unmap函数</span>
<span class="token keyword keyword-if">if</span><span class="token punctuation">(</span><span class="token punctuation">(</span>pte <span class="token operator">=</span> <span class="token function">walk</span><span class="token punctuation">(</span>pagetable<span class="token punctuation">,</span> a<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span>
    <span class="token keyword keyword-continue">continue</span><span class="token punctuation">;</span>
    <span class="token comment">// panic("uvmunmap: walk");</span>
  <span class="token keyword keyword-if">if</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token operator">*</span>pte <span class="token operator">&amp;</span> PTE_V<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span>
    <span class="token keyword keyword-continue">continue</span><span class="token punctuation">;</span>
    <span class="token comment">// panic("uvmunmap: not mapped");</span>
  <span class="token comment">//  注意这里要continue</span>
  <span class="token comment">// 如果不判断的话，会进入后续的kfree引发panic:kfree</span>

<span class="token comment">// walkaddr函数</span>
<span class="token comment">//if(pte == 0)</span>
  <span class="token comment">// return 0;</span>
<span class="token comment">//if((*pte &amp; PTE_V) == 0)</span>
  <span class="token comment">//return 0;</span>

<span class="token keyword keyword-if">if</span><span class="token punctuation">(</span>pte <span class="token operator">==</span> <span class="token number">0</span> <span class="token operator">||</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token operator">*</span>pte <span class="token operator">&amp;</span> PTE_V<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
  <span class="token keyword keyword-struct">struct</span> <span class="token class-name">proc</span> <span class="token operator">*</span>p <span class="token operator">=</span> <span class="token function">myproc</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  
  <span class="token comment">// 注意这里是能取等的,否则会有极端样例无法通过</span>
  <span class="token keyword keyword-if">if</span><span class="token punctuation">(</span>va <span class="token operator">&gt;=</span> p<span class="token operator">-&gt;</span>sz <span class="token operator">||</span> va <span class="token operator">&lt;</span> p<span class="token operator">-&gt;</span>trapframe<span class="token operator">-&gt;</span>sp<span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token keyword keyword-return">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>

  va <span class="token operator">=</span> <span class="token function">PGROUNDDOWN</span><span class="token punctuation">(</span>va<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token comment">// 这一步要注意，否则会freewalk:leaf</span>

  <span class="token comment">// 分配物理内存</span>
  <span class="token keyword keyword-char">char</span><span class="token operator">*</span> mem<span class="token punctuation">;</span>
  mem <span class="token operator">=</span> <span class="token function">kalloc</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword keyword-if">if</span><span class="token punctuation">(</span>mem <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token keyword keyword-return">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
  <span class="token function">memset</span><span class="token punctuation">(</span>mem <span class="token punctuation">,</span> <span class="token number">0</span> <span class="token punctuation">,</span> PGSIZE<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword keyword-if">if</span><span class="token punctuation">(</span><span class="token function">mappages</span><span class="token punctuation">(</span>p<span class="token operator">-&gt;</span>pagetable<span class="token punctuation">,</span> va<span class="token punctuation">,</span> PGSIZE<span class="token punctuation">,</span> <span class="token punctuation">(</span>uint64<span class="token punctuation">)</span>mem<span class="token punctuation">,</span> PTE_W<span class="token operator">|</span>PTE_X<span class="token operator">|</span>PTE_R<span class="token operator">|</span>PTE_U<span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token function">kfree</span><span class="token punctuation">(</span>mem<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword keyword-return">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
  <span class="token comment">// 注意，要返回找到的物理地址</span>
  <span class="token keyword keyword-return">return</span> <span class="token punctuation">(</span>uint64<span class="token punctuation">)</span>mem<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

</code></pre></details>
<h1 id="lec8">LEC8 </h1>
<h2 id="中断机制">中断机制 </h2>
<p>中断，指的是硬件想要得到操作系统关注；<br>
当操作系统遇到中断，需要保存当前的工作，处理中断，之后再恢复之前的工作；<br>
这个流程和之前的系统调用，page fault很相似；</p>
<p>中断的特殊之处为：<br>
硬件中断并不处于运行进程的上下文中，也就是说和CPU没关系；<br>
CPU与硬件设备之间是并行的；<br>
面对设备的编程更复杂；</p>
<p>接下来讨论以下问题：<br>
console中的"$"是怎么显示出来的；<br>
键盘上输入的"ls"是怎么在console中显示的；</p>
<p>回忆之前，内核的地址除了映射到RAM内存之外，还对设备有映射，因此可以直接对设备进行读写；<br>
管理设备中断的部分叫做PLIC；<br>
它的作用是暂时保存中断信息；<br>
然后通知CPU进行处理，有空闲CPU可用时，接收中断；<br>
CPU处理完中断后，通知PLIC，而后不再保存中断信息；</p>
<h2 id="设备驱动">设备驱动 </h2>
<p>管理设备的代码称为驱动，它们放在内存中；<br>
驱动分为bottom/top两个部分；</p>
<p>bottom部分进行中断处理，CPU调用这部分与硬件交互；<br>
这部分代码不处在任何进程上下文中，只处理中断；<br>
对设备编程是通过memory mapped I/O完成的；<br>
也就是CPU直接修改设备的控制寄存器；</p>
<p>top部分，用于和用户或者内核交互;<br>
可以理解为硬件为其他部分提供的接口；</p>
<p>驱动中还有一些队列(buffer)，top和bottom都可以使用，可以理解为二者交换信息的渠道；<br>
同时，这可以缓解硬件和软件处理速度不匹配的问题；</p>
<h2 id="uart设备">UART设备 </h2>
<p>UART是通用异步收发传输器，解决两个硬件设备之间如何传输数据；<br>
因此有两个UART芯片，一个用于传输，一个用于接收；</p>
<p>以shell打印"$"到console上为例：</p>
<p>一个UART芯片在CPU旁边，shell程序告诉CPU要打印"$"，CPU把这个字符交给旁边的UART芯片，UART完成传输之后产生一个中断，告诉CPU可以发送下一个数据；<br>
另一个UART芯片链接到console，接收到从前一个UART芯片传来的字符后，它会告知console打印字符；</p>
<p>输入"ls"几乎类似，键盘连接UART的一端，收到信息后传输给另一端；<br>
另一端的UART芯片收到数据后，会产生一个中断，并告知CPU来处理UART芯片收到的来自键盘的输入；</p>
<p>中断相关寄存器：<br>
SIE寄存器：S位处理软件中断，E位处理外部设备中断，T位处理定时器中断；<br>
SSATUS寄存器：打开或关闭中断；<br>
SIP寄存器：表明当前是什么类型的中断；<br>
SCAUSE寄存器：表明当前状态的原因是中断；<br>
STVEC寄存器：trap,page fault或中断时，CPU运行的用户的PC；</p>
<p>具体地，在代码中我们会做如下事情处理中断,以shell打印"$"到console上为例：<br>
consoleinit，初始化设备的过程中，会调用uartinit;<br>
uartinit会关闭中断设置，重置一些参数（UART之间传输用），再打开中断；<br>
CPU能够感知到中断，还需要初始化PLIC；<br>
plicinit函数声明能够接受来自那些设备的中断；<br>
plicinithart函数声明每个CPU核对于那些中断感兴趣；<br>
最后在进程调度scheduler函数中开启中断，即intr_on函数；<br>
这个函数的作用实际上就是设置SSATUTS寄存器的值；</p>
<h2 id="uart驱动">UART驱动 </h2>
<p>对于shell而言，console其实就是一个文件，它也有相应的文件描述符，我们也是通过写入文件的系统调用执行的；<br>
但在写入文件的时候，我们做了检查，发现文件的类型属于设备，因此我们启用的是针对设备的特定写入函数consolewrite；</p>
<p>我们知道这个过程是通过UART实现的，因此consolewrite会调用uartputc来传入一个字符给UART设备；<br>
这里consolewrite相当于UART驱动的top部分；<br>
uartputc把字符放入buffer中，这是一个环形队列，有读写2个头；<br>
之后会调用uartstart函数，这个函数的作用是检查UART是否空闲，并从buffer中读出字符放入THR(发送寄存器)中；</p>
<p>此后，当传输完成时，会收到中断；<br>
注意中断不是在uartstart和uastputc中手动触发的；<br>
而是在uartinit中，设置好了比如THR寄存器变空的时候触发中断，因此系统会自动收到中断提示；</p>
<p>当一个CPU核收到PLIC的中断提醒后，进行如下处理；<br>
首先清楚SIE寄存器中的位，防止该CPU核被其他中断打扰；<br>
用SEPC寄存器保存当前的PC；<br>
保存当前的模式，并切换到内核模式；<br>
最后将PC设置为STVEC的值，也就是进入trap处理程序的地址；</p>
<p>接下来，我们考察usertrap函数中之前被忽略的中断部分；<br>
中断处理调用了devintr函数；<br>
这个函数先检查SCAUSE寄存器判断是否为外部设备的中断，如果是则调用plic_claim获取中断；<br>
检查到来自UART后，会调用uartintr函数；</p>
<p>注意uartintr函数处理中断，一种是接受数据的中断，也就是shell发出指令要求写到console上去；<br>
另一种是发送数据中断，也就是键盘触发中断，要将数据发出去；</p>
<p>对于前者，使用uartgetc读入RHR寄存器，并写入console中；<br>
对于后者，回到uartstart中，从buffer中取出字符写入THR寄存器；</p>
<p>总结起来，UART不管发还是收数据都会触发中断；<br>
前者告诉CPU能够继续发下一个字符；<br>
后者告诉CPU要收一个字符了；</p>
<h2 id="中断并发">中断并发 </h2>
<p>CPU与设备之间是并行的，这就是说，UART向console发送字符，CPU返回执行shell，shell执行下一个系统调用是并行的；<br>
用户代码会被中断打断，内核代码也会被中断打断，但是我们并没有设计诸如trap那样保存用户空间的机制，因此对于内核中一些不能被打断的地方，需要关闭中断；<br>
驱动的top和bottom是并行的，top部分将空格写入buffer和另一个CPU核执行bottom部分读取buffer是并行的；</p>
<h1 id="lec9">LEC9 </h1>
<h2 id="锁">锁 </h2>
<p>多个CPU核共同读取、写入数据，需要使用锁来协调数据的更新，确保共享的数据是正确的；</p>
<p>不上锁的的话会导致race condition，看以下处理空闲页表的例子：</p>
<pre data-role="codeBlock" data-info="c" class="language-c c"><code><span class="token function">acquire</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>kmem<span class="token punctuation">.</span>lock<span class="token punctuation">)</span><span class="token punctuation">;</span>
r<span class="token operator">-&gt;</span>next <span class="token operator">=</span> kmem<span class="token punctuation">.</span>freelist<span class="token punctuation">;</span>
kmem<span class="token punctuation">.</span>freelist <span class="token operator">=</span> r<span class="token punctuation">;</span>
<span class="token function">release</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>kmem<span class="token punctuation">.</span>lock<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><p>如果没有锁的话，更改空闲页表指针的操作会出错；<br>
因为可能核心1读取了当前kmem.freelist，核心2同时也读取了kmem.freelist；<br>
此后核心1先进行kmem.freelist的赋值，核心2后进行；<br>
这样的话，核心1的r就没有被添加到空闲列表中；<br>
如果有第三个CPU核，可能会先把自己的r-&gt;next改成核心1的r，但是此后核心1的r却并不在freelist链表中；</p>
<h2 id="锁的使用">锁的使用 </h2>
<p>锁会限制并发性，因此我们需要谨慎地选择使用锁的时机；<br>
一个简单而保守的规则是，只要访问共享的数据结构，并且会更新的话，就应该对共享的数据结构加锁；</p>
<p>当然也有其他情况需要锁，比如printf，我们希望完整地输出printf的内容，而不是和其他程序并行输出；</p>
<p>然而，直接为每一个结构体都分配一把锁是不明智的；<br>
比如要把文件d1/x重命名为d2/y；<br>
执行两个操作，对d1删除x，对d2添加y；<br>
如果分别对d1，d2上锁，执行各自的删除和添加操作，那么在其他程序看来，存在某一时刻d1,d2中都没有东西；<br>
因此我们需要维护一把d1,d2共同的锁，锁的中间执行删除d1/x和添加d2/y的两步操作；</p>
<h2 id="死锁">死锁 </h2>
<p>不恰当地使用锁会带来问题，比如说两次acquire同一个锁中间没有release；<br>
这样第二把锁由于第一把锁没有释放，无法执行其中的内容；<br>
第一把锁由于第二把锁的位置被卡住，遇不到自己的release；</p>
<p>另一个例子是，核1希望把d1/x改到d2/y；核2希望把d2/a改到d1/b；<br>
如果两个核是并行的，核1拥有d1锁，核2拥有d2锁，此时核1无法获取到d2锁，核2也无法获取到d1锁；</p>
<p>解决问题的方法是，对所有锁排序，以相同的顺序获取锁；<br>
比如以上我们规定只能先加d1锁再加d2锁，则不会出现问题；</p>
<p>然而排序是困难的，比如函数f1调用了函数f2，照理f1不应该知道f2的实现是什么样的，但是我们却需要把f2中用了哪些锁告诉f1；</p>
<h2 id="锁的实现">锁的实现 </h2>
<p>锁的特性是只有一个进程可以获取锁，任何时间点不能有超过一个锁的持有者；<br>
因此最主要的问题是解决acquire；</p>
<p>一个简单的想法是，在acquire中一直等，直到锁的标记为0，代表锁可以使用，为其打上标记并返回；<br>
但这么做是有问题的，因为如果两个进程同时检测到锁的标记为0，就会同时获取锁，仍然无法避免race condition。</p>
<p>解决问题的方法是借助特殊硬件指令amoswap；<br>
amoswap是硬件提供的原子操作，接收address,寄存器r1，寄存器r2；<br>
原子性地把r1中数据写入address中，把address数据写入r2中；<br>
这样的一个操作称为test and set；</p>
<p>在C语言标准库中，已经定义了这样的原子操作，因此可以使用：</p>
<pre data-role="codeBlock" data-info="c" class="language-c c"><code><span class="token keyword keyword-while">while</span><span class="token punctuation">(</span><span class="token function">__sync_lock_test_and_set</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>lk<span class="token operator">-&gt;</span>locked <span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token operator">!=</span><span class="token number">0</span><span class="token punctuation">)</span>
<span class="token punctuation">;</span>
</code></pre><p>其实就是让之前的检测和写入操作从硬件上成为原子性的；</p>
<p>在release过程，我们也使用原子操作amoswap(0 , 0 , s)即可原子性的把标记0写入；<br>
这里其实让人有疑问，不是只需要存0这一个操作吗，为什么store不是原子性的呢？<br>
实际上这和具体实现有关，比如说CPU内有cache line，则store会先加载cache line再更新，因此不是原子化的；<br>
总而言之，不能把看起来像是只执行了一个命令的操作当成原子化的；</p>
<p>需要注意的是CPU上中断和普通程序之间的并发；<br>
如果在持有锁的期间触发了中断，而中断处理函数又需要相同的锁，就会产生死锁；<br>
因此我们在acquire函数中，需要先关闭中断；</p>
<p>此外，锁的实现中acquire和release都包含了__sync_synchronize指令，目的是避免编译器重排指令导致锁失效；<br>
这个指令的意思是，任何在它前面的指令不能移动到后面，反之亦然；</p>
<h2 id="lab6--copy-on-write-fork-for-xv6">Lab6 : Copy-on-Write Fork for xv6 </h2>
<p>点击可以展开实验的具体代码实现：</p>
<details>
<summary>cow</summary>
<p>在kernel/kalloc.c中定义好页表统计结构体以及备用函数：</p>
<pre data-role="codeBlock" data-info="c" class="language-c c"><code><span class="token comment">// 每个物理页被多少进程使用</span>
<span class="token keyword keyword-struct">struct</span> <span class="token punctuation">{</span>
<span class="token comment">// 所有进程共同使用一个数组，因此需要一个锁保护</span>
<span class="token keyword keyword-struct">struct</span> <span class="token class-name">spinlock</span> lock<span class="token punctuation">;</span>
<span class="token keyword keyword-int">int</span> count<span class="token punctuation">[</span><span class="token function">PGROUNDDOWN</span><span class="token punctuation">(</span>PHYSTOP<span class="token punctuation">)</span> <span class="token operator">/</span> PGSIZE<span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span> page_count<span class="token punctuation">;</span>


<span class="token keyword keyword-void">void</span>
<span class="token function">page_count_init</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
<span class="token comment">// 初始时设定为0</span>
<span class="token function">initlock</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>page_count<span class="token punctuation">.</span>lock <span class="token punctuation">,</span> <span class="token string">"page_count"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword keyword-for">for</span><span class="token punctuation">(</span><span class="token keyword keyword-int">int</span> i <span class="token operator">=</span> <span class="token number">0</span> <span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token function">PGROUNDDOWN</span><span class="token punctuation">(</span>PHYSTOP<span class="token punctuation">)</span> <span class="token operator">/</span> PGSIZE <span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>
  page_count<span class="token punctuation">.</span>count<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword keyword-void">void</span>
<span class="token function">page_count_inc</span><span class="token punctuation">(</span>uint64 pa<span class="token punctuation">)</span><span class="token punctuation">{</span>
<span class="token function">acquire</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>page_count<span class="token punctuation">.</span>lock<span class="token punctuation">)</span><span class="token punctuation">;</span>
page_count<span class="token punctuation">.</span>count<span class="token punctuation">[</span><span class="token function">PGROUNDDOWN</span><span class="token punctuation">(</span>pa<span class="token punctuation">)</span><span class="token operator">/</span> PGSIZE<span class="token punctuation">]</span><span class="token operator">++</span><span class="token punctuation">;</span>
<span class="token function">release</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>page_count<span class="token punctuation">.</span>lock<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword keyword-void">void</span>
<span class="token function">page_count_dec</span><span class="token punctuation">(</span>uint64 pa<span class="token punctuation">)</span><span class="token punctuation">{</span>
<span class="token function">acquire</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>page_count<span class="token punctuation">.</span>lock<span class="token punctuation">)</span><span class="token punctuation">;</span>
page_count<span class="token punctuation">.</span>count<span class="token punctuation">[</span><span class="token function">PGROUNDDOWN</span><span class="token punctuation">(</span>pa<span class="token punctuation">)</span><span class="token operator">/</span> PGSIZE<span class="token punctuation">]</span><span class="token operator">--</span><span class="token punctuation">;</span>
<span class="token function">release</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>page_count<span class="token punctuation">.</span>lock<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><p>在kernel/defs.h中声明：</p>
<pre data-role="codeBlock" data-info="c" class="language-c c"><code><span class="token keyword keyword-void">void</span>            <span class="token function">page_count_inc</span><span class="token punctuation">(</span>uint64<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword keyword-void">void</span>            <span class="token function">page_count_inc</span><span class="token punctuation">(</span>uint64<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><p>在kernel/kalloc.c中修改以下函数：</p>
<pre data-role="codeBlock" data-info="c" class="language-c c"><code><span class="token keyword keyword-void">void</span>
<span class="token function">kinit</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
<span class="token function">page_count_init</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 初始化</span>
<span class="token function">initlock</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>kmem<span class="token punctuation">.</span>lock<span class="token punctuation">,</span> <span class="token string">"kmem"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token function">freerange</span><span class="token punctuation">(</span>end<span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token keyword keyword-void">void</span><span class="token operator">*</span><span class="token punctuation">)</span>PHYSTOP<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword keyword-void">void</span>
<span class="token function">kfree</span><span class="token punctuation">(</span><span class="token keyword keyword-void">void</span> <span class="token operator">*</span>pa<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
<span class="token keyword keyword-struct">struct</span> <span class="token class-name">run</span> <span class="token operator">*</span>r<span class="token punctuation">;</span>

<span class="token keyword keyword-if">if</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">(</span>uint64<span class="token punctuation">)</span>pa <span class="token operator">%</span> PGSIZE<span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token number">0</span> <span class="token operator">||</span> <span class="token punctuation">(</span><span class="token keyword keyword-char">char</span><span class="token operator">*</span><span class="token punctuation">)</span>pa <span class="token operator">&lt;</span> end <span class="token operator">||</span> <span class="token punctuation">(</span>uint64<span class="token punctuation">)</span>pa <span class="token operator">&gt;=</span> PHYSTOP<span class="token punctuation">)</span>
  <span class="token function">panic</span><span class="token punctuation">(</span><span class="token string">"kfree"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">// kfree的作用是减少一次引用</span>
<span class="token comment">// 仅在引用减为0时释放物理页</span>
<span class="token function">page_count_dec</span><span class="token punctuation">(</span><span class="token punctuation">(</span>uint64<span class="token punctuation">)</span> pa<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword keyword-if">if</span><span class="token punctuation">(</span>page_count<span class="token punctuation">.</span>count<span class="token punctuation">[</span><span class="token function">PGROUNDDOWN</span><span class="token punctuation">(</span><span class="token punctuation">(</span>uint64<span class="token punctuation">)</span> pa<span class="token punctuation">)</span> <span class="token operator">/</span> PGSIZE<span class="token punctuation">]</span> <span class="token operator">&gt;</span> <span class="token number">0</span><span class="token punctuation">)</span>
  <span class="token keyword keyword-return">return</span><span class="token punctuation">;</span>

<span class="token comment">// Fill with junk to catch dangling refs.</span>
<span class="token function">memset</span><span class="token punctuation">(</span>pa<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> PGSIZE<span class="token punctuation">)</span><span class="token punctuation">;</span>

r <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword keyword-struct">struct</span> <span class="token class-name">run</span><span class="token operator">*</span><span class="token punctuation">)</span>pa<span class="token punctuation">;</span>

<span class="token function">acquire</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>kmem<span class="token punctuation">.</span>lock<span class="token punctuation">)</span><span class="token punctuation">;</span>
r<span class="token operator">-&gt;</span>next <span class="token operator">=</span> kmem<span class="token punctuation">.</span>freelist<span class="token punctuation">;</span>
kmem<span class="token punctuation">.</span>freelist <span class="token operator">=</span> r<span class="token punctuation">;</span>
<span class="token function">release</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>kmem<span class="token punctuation">.</span>lock<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword keyword-void">void</span> <span class="token operator">*</span>
<span class="token function">kalloc</span><span class="token punctuation">(</span><span class="token keyword keyword-void">void</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
<span class="token keyword keyword-struct">struct</span> <span class="token class-name">run</span> <span class="token operator">*</span>r<span class="token punctuation">;</span>

<span class="token function">acquire</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>kmem<span class="token punctuation">.</span>lock<span class="token punctuation">)</span><span class="token punctuation">;</span>
r <span class="token operator">=</span> kmem<span class="token punctuation">.</span>freelist<span class="token punctuation">;</span>
<span class="token keyword keyword-if">if</span><span class="token punctuation">(</span>r<span class="token punctuation">)</span>
  kmem<span class="token punctuation">.</span>freelist <span class="token operator">=</span> r<span class="token operator">-&gt;</span>next<span class="token punctuation">;</span>
<span class="token function">release</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>kmem<span class="token punctuation">.</span>lock<span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token keyword keyword-if">if</span><span class="token punctuation">(</span>r<span class="token punctuation">)</span><span class="token punctuation">{</span>
  <span class="token function">memset</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token keyword keyword-char">char</span><span class="token operator">*</span><span class="token punctuation">)</span>r<span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">,</span> PGSIZE<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// fill with junk</span>
  <span class="token comment">// 更新计数器</span>
  <span class="token function">page_count_inc</span><span class="token punctuation">(</span><span class="token punctuation">(</span>uint64<span class="token punctuation">)</span> r<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token keyword keyword-return">return</span> <span class="token punctuation">(</span><span class="token keyword keyword-void">void</span><span class="token operator">*</span><span class="token punctuation">)</span>r<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword keyword-void">void</span>
<span class="token function">freerange</span><span class="token punctuation">(</span><span class="token keyword keyword-void">void</span> <span class="token operator">*</span>pa_start<span class="token punctuation">,</span> <span class="token keyword keyword-void">void</span> <span class="token operator">*</span>pa_end<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
<span class="token keyword keyword-char">char</span> <span class="token operator">*</span>p<span class="token punctuation">;</span>
p <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword keyword-char">char</span><span class="token operator">*</span><span class="token punctuation">)</span><span class="token function">PGROUNDUP</span><span class="token punctuation">(</span><span class="token punctuation">(</span>uint64<span class="token punctuation">)</span>pa_start<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword keyword-for">for</span><span class="token punctuation">(</span><span class="token punctuation">;</span> p <span class="token operator">+</span> PGSIZE <span class="token operator">&lt;=</span> <span class="token punctuation">(</span><span class="token keyword keyword-char">char</span><span class="token operator">*</span><span class="token punctuation">)</span>pa_end<span class="token punctuation">;</span> p <span class="token operator">+=</span> PGSIZE<span class="token punctuation">)</span><span class="token punctuation">{</span>
  <span class="token function">kfree</span><span class="token punctuation">(</span>p<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token comment">// 调用了kfree减少，因此初始会变成-1，应该加回来</span>
  <span class="token function">page_count_inc</span><span class="token punctuation">(</span><span class="token punctuation">(</span>uint64<span class="token punctuation">)</span> p<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>    
<span class="token punctuation">}</span>
</code></pre><p>在kernel/riscv.h中添加声明：</p>
<pre data-role="codeBlock" data-info="c" class="language-c c"><code><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">PTE_COW</span> <span class="token expression"><span class="token punctuation">(</span><span class="token number">1L</span> <span class="token operator">&lt;&lt;</span> <span class="token number">8</span><span class="token punctuation">)</span></span></span>
</code></pre><p>在kernel/vm.c中添加函数并在kernel/defs.h中添加声明：</p>
<pre data-role="codeBlock" data-info="c" class="language-c c"><code><span class="token keyword keyword-int">int</span>
<span class="token function">cow_alloc</span><span class="token punctuation">(</span><span class="token class-name">pagetable_t</span>  pagetable<span class="token punctuation">,</span> uint64 va<span class="token punctuation">)</span><span class="token punctuation">{</span>
<span class="token comment">// 为cow页面申请一个新的物理页，并减少一次之前的物理页引用</span>

<span class="token comment">// 需要在这里判断，否则进入到walk中触发panic</span>
<span class="token keyword keyword-if">if</span><span class="token punctuation">(</span>va <span class="token operator">&gt;=</span> MAXVA<span class="token punctuation">)</span>
  <span class="token keyword keyword-return">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>

<span class="token class-name">pte_t</span> <span class="token operator">*</span>pte<span class="token punctuation">;</span>
<span class="token keyword keyword-if">if</span><span class="token punctuation">(</span><span class="token punctuation">(</span>pte <span class="token operator">=</span> <span class="token function">walk</span><span class="token punctuation">(</span>pagetable<span class="token punctuation">,</span> va<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span>
  <span class="token keyword keyword-return">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>
<span class="token keyword keyword-if">if</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token operator">*</span>pte <span class="token operator">&amp;</span> PTE_V<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span>
  <span class="token keyword keyword-return">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>

uint64 pa <span class="token punctuation">,</span> flags<span class="token punctuation">;</span>
pa <span class="token operator">=</span> <span class="token function">PTE2PA</span><span class="token punctuation">(</span><span class="token operator">*</span>pte<span class="token punctuation">)</span><span class="token punctuation">;</span>
flags <span class="token operator">=</span> <span class="token function">PTE_FLAGS</span><span class="token punctuation">(</span><span class="token operator">*</span>pte<span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token keyword keyword-if">if</span><span class="token punctuation">(</span>flags <span class="token operator">&amp;</span> PTE_COW<span class="token punctuation">)</span><span class="token punctuation">{</span>
  <span class="token comment">// 确实是写入cow页面</span>
  <span class="token keyword keyword-char">char</span> <span class="token operator">*</span>mem<span class="token punctuation">;</span>
  <span class="token keyword keyword-if">if</span><span class="token punctuation">(</span><span class="token punctuation">(</span>mem <span class="token operator">=</span> <span class="token function">kalloc</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span>
    <span class="token keyword keyword-return">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>
  <span class="token function">memmove</span><span class="token punctuation">(</span>mem<span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token keyword keyword-char">char</span><span class="token operator">*</span><span class="token punctuation">)</span>pa<span class="token punctuation">,</span> PGSIZE<span class="token punctuation">)</span><span class="token punctuation">;</span>

  <span class="token comment">// 退出PTE_COW设置，并打上可写标记</span>
  flags <span class="token operator">=</span> <span class="token punctuation">(</span>flags <span class="token operator">&amp;</span> <span class="token punctuation">(</span><span class="token operator">~</span>PTE_COW<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  flags <span class="token operator">=</span> flags <span class="token operator">|</span> PTE_W<span class="token punctuation">;</span>

  <span class="token comment">// 映射到新的物理页mem</span>
  <span class="token operator">*</span>pte <span class="token operator">=</span> <span class="token function">PA2PTE</span><span class="token punctuation">(</span>mem<span class="token punctuation">)</span> <span class="token operator">|</span> flags<span class="token punctuation">;</span>

  <span class="token comment">// 如果物理页无引用，则清除（kfree中本身带有减少计数）</span>
  <span class="token function">kfree</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token keyword keyword-void">void</span><span class="token operator">*</span><span class="token punctuation">)</span> pa<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword keyword-return">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><p>修改kernel/vm.c中的函数：</p>
<pre data-role="codeBlock" data-info="c" class="language-c c"><code><span class="token keyword keyword-int">int</span>
<span class="token function">uvmcopy</span><span class="token punctuation">(</span><span class="token class-name">pagetable_t</span> old<span class="token punctuation">,</span> <span class="token class-name">pagetable_t</span> new<span class="token punctuation">,</span> uint64 sz<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
<span class="token class-name">pte_t</span> <span class="token operator">*</span>pte<span class="token punctuation">;</span>
uint64 pa<span class="token punctuation">,</span> i<span class="token punctuation">;</span>
uint64 flags<span class="token punctuation">;</span>
<span class="token comment">// char *mem;</span>

<span class="token keyword keyword-for">for</span><span class="token punctuation">(</span>i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> sz<span class="token punctuation">;</span> i <span class="token operator">+=</span> PGSIZE<span class="token punctuation">)</span><span class="token punctuation">{</span>
  <span class="token keyword keyword-if">if</span><span class="token punctuation">(</span><span class="token punctuation">(</span>pte <span class="token operator">=</span> <span class="token function">walk</span><span class="token punctuation">(</span>old<span class="token punctuation">,</span> i<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span>
    <span class="token function">panic</span><span class="token punctuation">(</span><span class="token string">"uvmcopy: pte should exist"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword keyword-if">if</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token operator">*</span>pte <span class="token operator">&amp;</span> PTE_V<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span>
    <span class="token function">panic</span><span class="token punctuation">(</span><span class="token string">"uvmcopy: page not present"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

  pa <span class="token operator">=</span> <span class="token function">PTE2PA</span><span class="token punctuation">(</span><span class="token operator">*</span>pte<span class="token punctuation">)</span><span class="token punctuation">;</span>
  flags <span class="token operator">=</span> <span class="token function">PTE_FLAGS</span><span class="token punctuation">(</span><span class="token operator">*</span>pte<span class="token punctuation">)</span><span class="token punctuation">;</span>

  <span class="token comment">// 清除父进程的可写标志</span>
  flags <span class="token operator">=</span> flags <span class="token operator">|</span> PTE_COW<span class="token punctuation">;</span>
  flags <span class="token operator">=</span> flags <span class="token operator">&amp;</span> <span class="token punctuation">(</span><span class="token operator">~</span>PTE_W<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token operator">*</span>pte <span class="token operator">=</span> <span class="token function">PA2PTE</span><span class="token punctuation">(</span>pa<span class="token punctuation">)</span> <span class="token operator">|</span> flags<span class="token punctuation">;</span>

  <span class="token comment">// if((mem = kalloc()) == 0)</span>
    <span class="token comment">// goto err;</span>
  <span class="token comment">// memmove(mem, (char*)pa, PGSIZE);</span>

  <span class="token comment">// 增加物理页的引用数</span>
  <span class="token function">page_count_inc</span><span class="token punctuation">(</span>pa<span class="token punctuation">)</span><span class="token punctuation">;</span>

  <span class="token comment">// 注意是共享物理页，而不是共享页表！！</span>
  <span class="token keyword keyword-if">if</span><span class="token punctuation">(</span><span class="token function">mappages</span><span class="token punctuation">(</span>new<span class="token punctuation">,</span> i<span class="token punctuation">,</span> PGSIZE<span class="token punctuation">,</span> <span class="token punctuation">(</span>uint64<span class="token punctuation">)</span>pa<span class="token punctuation">,</span> flags<span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token comment">// kfree(mem);</span>
    <span class="token keyword keyword-goto">goto</span> err<span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span class="token keyword keyword-return">return</span> <span class="token number">0</span><span class="token punctuation">;</span>

err<span class="token operator">:</span>
<span class="token function">uvmunmap</span><span class="token punctuation">(</span>new<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> i <span class="token operator">/</span> PGSIZE<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword keyword-return">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword keyword-int">int</span>
<span class="token function">copyout</span><span class="token punctuation">(</span><span class="token class-name">pagetable_t</span> pagetable<span class="token punctuation">,</span> uint64 dstva<span class="token punctuation">,</span> <span class="token keyword keyword-char">char</span> <span class="token operator">*</span>src<span class="token punctuation">,</span> uint64 len<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
uint64 n<span class="token punctuation">,</span> va0<span class="token punctuation">,</span> pa0<span class="token punctuation">;</span>

<span class="token keyword keyword-while">while</span><span class="token punctuation">(</span>len <span class="token operator">&gt;</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
  va0 <span class="token operator">=</span> <span class="token function">PGROUNDDOWN</span><span class="token punctuation">(</span>dstva<span class="token punctuation">)</span><span class="token punctuation">;</span>

  <span class="token comment">// 这个步骤跳过了page fault，因此需要分配新的物理页面</span>
  <span class="token keyword keyword-if">if</span><span class="token punctuation">(</span><span class="token function">cow_alloc</span><span class="token punctuation">(</span>pagetable <span class="token punctuation">,</span> va0<span class="token punctuation">)</span> <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span>
    <span class="token keyword keyword-return">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>

  pa0 <span class="token operator">=</span> <span class="token function">walkaddr</span><span class="token punctuation">(</span>pagetable<span class="token punctuation">,</span> va0<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword keyword-if">if</span><span class="token punctuation">(</span>pa0 <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span>
    <span class="token keyword keyword-return">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>
  n <span class="token operator">=</span> PGSIZE <span class="token operator">-</span> <span class="token punctuation">(</span>dstva <span class="token operator">-</span> va0<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword keyword-if">if</span><span class="token punctuation">(</span>n <span class="token operator">&gt;</span> len<span class="token punctuation">)</span>
    n <span class="token operator">=</span> len<span class="token punctuation">;</span>
  <span class="token function">memmove</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token keyword keyword-void">void</span> <span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">(</span>pa0 <span class="token operator">+</span> <span class="token punctuation">(</span>dstva <span class="token operator">-</span> va0<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">,</span> src<span class="token punctuation">,</span> n<span class="token punctuation">)</span><span class="token punctuation">;</span>

  len <span class="token operator">-=</span> n<span class="token punctuation">;</span>
  src <span class="token operator">+=</span> n<span class="token punctuation">;</span>
  dstva <span class="token operator">=</span> va0 <span class="token operator">+</span> PGSIZE<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token keyword keyword-return">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><p>在kernel/trap.c中修改函数usertrap:</p>
<pre data-role="codeBlock" data-info="c" class="language-c c"><code><span class="token keyword keyword-else">else</span> <span class="token keyword keyword-if">if</span><span class="token punctuation">(</span><span class="token function">r_scause</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">13</span> <span class="token operator">||</span> <span class="token function">r_scause</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">15</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
  <span class="token comment">// 进入page fault处理</span>

  <span class="token comment">// 获取触发page fault的虚拟地址</span>
  uint64 va <span class="token operator">=</span> <span class="token function">r_stval</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

  <span class="token comment">// 判断虚拟地址是否有效，不能在保护页中</span>
  <span class="token keyword keyword-if">if</span><span class="token punctuation">(</span>va <span class="token operator">&gt;=</span> MAXVA <span class="token operator">||</span><span class="token punctuation">(</span> <span class="token punctuation">(</span>va <span class="token operator">&lt;</span> p<span class="token operator">-&gt;</span>trapframe<span class="token operator">-&gt;</span>sp<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> <span class="token punctuation">(</span>va <span class="token operator">&gt;=</span> p<span class="token operator">-&gt;</span>trapframe<span class="token operator">-&gt;</span>sp <span class="token operator">-</span> PGSIZE<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token function">exit</span><span class="token punctuation">(</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>

  va <span class="token operator">=</span> <span class="token function">PGROUNDDOWN</span><span class="token punctuation">(</span>va<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword keyword-if">if</span><span class="token punctuation">(</span><span class="token function">cow_alloc</span><span class="token punctuation">(</span>p<span class="token operator">-&gt;</span>pagetable <span class="token punctuation">,</span> va<span class="token punctuation">)</span> <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token function">exit</span><span class="token punctuation">(</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>

<span class="token punctuation">}</span>
</code></pre></details>
<h1 id="lec10">LEC10 </h1>
<h2 id="线程">线程 </h2>
<p>线程：串行执行代码的单元</p>
<p>线程的状态：<br>
程序计数器，PC；<br>
保存变量的寄存器；<br>
程序的栈；</p>
<p>多线程并行策略：一个CPU在多个线程之间来回切换；</p>
<p>理论上说，一个进程可以拥有多个线程，它们之间并行处理任务，但是xv6不支持该功能；<br>
xv6具有两种线程，一种是内核线程，一种是用户线程；<br>
但是每个进程仅有一个用户线程和内核线程；<br>
用户线程各自而对内存地址空间是独立的；<br>
内核线程的内存地址空间是公共的，因此需要锁来保证正确的内存共享；<br>
当然，实际上二者并不能够进行线程的并行，只是不同模式的体现；</p>
<h2 id="线程调度">线程调度 </h2>
<p>每个CPU核都有一个线程调度器scheduler；<br>
执行线程调度的时候，为线程进行分类：<br>
RUNNING，线程当前在某个CPU上运行；<br>
RUNNABLE，线程还没有在某个CPU上运行，但是一旦有空闲CPU就可以运行；<br>
SLEEPING，线程正在等待一些I/O事件；</p>
<p>一种让RUNNING变成RUNNABLE的方式是触发中断；<br>
需要注意的是RUNNING线程的PC和寄存器位于CPU中；<br>
但是RUNNABLE线程和CPU没有关系，它的信息保存在内存中；</p>
<h2 id="线程切换">线程切换 </h2>
<p>之前我们其实已经了解过这种线程之间的切换；<br>
比如进程从用户空间进入内核空间时，需要把寄存器信息存在trapframe中；<br>
而从内核空间回到用户空间是，也需要先从trapframe中加载回这些寄存器的值；</p>
<p>与之类似，想要实现进程之间用户级或者内核级的切换；<br>
只需要再把内核寄存器保存在一个context对象即可，因为用户寄存器已经保存在了trapframe中；</p>
<p>注意，进程之间的切换总是在内核中切换的：<br>
A进程会先从用户态进入内核态，把用户寄存器保存到trapframe中；<br>
从A进程的内核态转移到B进程的内核态；<br>
再加载B进程的trapframe中的寄存器，进入B进程的用户态；</p>
<p>从用户态进入内核态的一种常见情况是由定时器中断实现的；<br>
定时器中断指的是每隔一定时间，就让进程进入一次内核态；<br>
此时调度器就会介入，选择下一个需要运行的进程；<br>
这种机制保证了不会在一个进程中卡死，可以实现进程的转换；</p>
<p>从一个进程转移到另一个进程的内核态的详细过程如下：<br>
在A进程的内核线程中，最关键的一部是执行swtch函数；<br>
这个函数会把A进程的内核线程寄存器保存到context对象；<br>
接下来，会切换到CPU核上的调度器线程；<br>
注意调度器线程也是内核线程，它的内核寄存器也保存在自己的context中；<br>
之后调度器线程执行scheduler函数，完成清理工作；<br>
比如设定进程A为RUNNABLE，并通过进程表找到进程B;<br>
之后scheduler函数会调用swtch函数，把自己的调度线程寄存器保存到context中，并找到进程B的context；<br>
切换到进程B的context后，就正式进入了进程B的内核；<br>
注意此时进程B应该在中断处理或者系统调用中，能够回到自己的用户空间；</p>
<p>context保存在进程的proc结构体中；<br>
而调度器线程没有自己的proc结构体，因此它被保存在cpu结构体中；<br>
context对象只会来源于swtch函数；</p>
<h2 id="代码解析">代码解析 </h2>
<p>识别到定时器中断后，会调用函数yield；<br>
yield会打开这个进程的锁，在这个锁中执行两件事；<br>
其一是将程序状态改为RUNNABLE；<br>
另一个是调用sched函数；<br>
这里必须使用锁是因为要防止其它CPU看到当前的进程改为了RUNNABLE后调用这个进程；</p>
<p>sched函数只执行了一些合理性检查，并调用了函数swtch；<br>
swtch函数的两个参数是p-&gt;context和c-&gt;context；<br>
分别表示进程的context对象和cpu的context对象（属于调度器线程）；</p>
<p>注意swtch函数需要保存、修改寄存器，因此是用汇编语言写的；<br>
swtch函数所做的主要事情就是，把当前寄存器写入第一个参数对应的寄存器（进程A的内核线程）；<br>
再第二个参数的寄存器（调度线程）值载入当前寄存器中；</p>
<p>注意这里并不需要保持所有的寄存器，因为swtch函数是C代码调用的，而caller saved寄存器会被C编译器保存在当前的栈上，因此只需要保存callee寄存器即可；</p>
<p>完成这些之后，实际上已经处于调度器线程的swtch函数的返回状态了，这是因为上一次从调度器线程出去就是在swtch函数中；<br>
返回之后，我们会进入函数scheduler中；<br>
<img src="..\assets\images\s.6081\image-12.png" alt="alt text"><br>
注意，这里的进入scheduler函数并不是进入scheduler函数的出发点；<br>
而是进入scheduler函数中swtch函数的返回状态；<br>
注意，我们获得了进程的锁之后，并没有关闭锁；<br>
而是一路从yield到sched到swtch到scheduler中，因此现在需要释放这个进程的锁了；<br>
不过我们马上要进入调度状态，避免其它逻辑认为cpu上有进程运行，因此在释放锁之前还需要让c-&gt;proc=0；</p>
<p>scheduler函数的主体是一个循环，释放完锁之后，会进入下一个循环，找到新的可执行进程；<br>
如果说找到了，将会进行一些设置后，再次进入swtch函数，从而进入到目标进程的内核线程中；<br>
这里swtch函数返回之后，就会回到目标进程中的sched函数后再回到yield函数中；</p>
<p>需要注意的是这里的锁，如果进入了swtch函数，实际上锁的两端分别位于yield函数和scheduler函数中；<br>
当然这里主要聚焦于通过定时器中断触发线程切换，实际上还有其他的系统调用比如说sleep能触发线程切换，也需要调用swtch函数；</p>
<p>需要注意的是，swtch函数会跳到另一个已经存在的swtch函数中，那么对于第一个swtch函数而言，它会回到什么位置呢？<br>
在申请进程allocproc中，会设置好新进程的context，并把其中的返回地址context.ra保存为forkret函数；<br>
forkret函数会表现得像刚调用完swtch函数一样，因此需要同样先释放锁，再进入usertrapret函数；<br>
usertrapret也是一个假的函数，让程序表现得像刚从trap中返回一样；</p>
<h2 id="lab7--multithreading">Lab7 : Multithreading </h2>
<p>点击可以展开以下实验的具体代码实现：</p>
<details>
<summary>uthread</summary>
<p>在user/uthread.c中添加如下代码，定义结构体：</p>
<pre data-role="codeBlock" data-info="c" class="language-c c"><code><span class="token keyword keyword-struct">struct</span> <span class="token class-name">context</span> <span class="token punctuation">{</span>
  uint64 ra<span class="token punctuation">;</span>
  uint64 sp<span class="token punctuation">;</span>

  <span class="token comment">// callee-saved</span>
  uint64 s0<span class="token punctuation">;</span>
  uint64 s1<span class="token punctuation">;</span>
  uint64 s2<span class="token punctuation">;</span>
  uint64 s3<span class="token punctuation">;</span>
  uint64 s4<span class="token punctuation">;</span>
  uint64 s5<span class="token punctuation">;</span>
  uint64 s6<span class="token punctuation">;</span>
  uint64 s7<span class="token punctuation">;</span>
  uint64 s8<span class="token punctuation">;</span>
  uint64 s9<span class="token punctuation">;</span>
  uint64 s10<span class="token punctuation">;</span>
  uint64 s11<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword keyword-struct">struct</span> <span class="token class-name">thread</span> <span class="token punctuation">{</span>
  <span class="token keyword keyword-char">char</span>       stack<span class="token punctuation">[</span>STACK_SIZE<span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment">/* the thread's stack */</span>
  <span class="token keyword keyword-int">int</span>        state<span class="token punctuation">;</span>             <span class="token comment">/* FREE, RUNNING, RUNNABLE */</span>
  <span class="token keyword keyword-struct">struct</span> <span class="token class-name">context</span> context<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre><p>修改user/uthread.c中的thread_schedule和thread_create函数：</p>
<pre data-role="codeBlock" data-info="c" class="language-c c"><code><span class="token comment">// thread_schedule</span>
<span class="token comment">/* YOUR CODE HERE
  * Invoke thread_switch to switch from t to next_thread:
  * thread_switch(??, ??);
  */</span>
<span class="token function">thread_switch</span><span class="token punctuation">(</span><span class="token punctuation">(</span>uint64<span class="token punctuation">)</span> <span class="token operator">&amp;</span>t<span class="token operator">-&gt;</span>context <span class="token punctuation">,</span> <span class="token punctuation">(</span>uint64<span class="token punctuation">)</span> <span class="token operator">&amp;</span>current_thread<span class="token operator">-&gt;</span>context<span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">// thread_create</span>
<span class="token comment">// YOUR CODE HERE</span>
t<span class="token operator">-&gt;</span>context<span class="token punctuation">.</span>ra <span class="token operator">=</span> <span class="token punctuation">(</span>uint64<span class="token punctuation">)</span> func<span class="token punctuation">;</span> <span class="token comment">// 线程的入口点是传入的指定函数</span>
t<span class="token operator">-&gt;</span>context<span class="token punctuation">.</span>sp <span class="token operator">=</span> <span class="token punctuation">(</span>uint64<span class="token punctuation">)</span> t<span class="token operator">-&gt;</span>stack <span class="token operator">+</span> STACK_SIZE<span class="token punctuation">;</span>
</code></pre><p>从kernel/swtch.S中复制函数到uthread_switch.S中：</p>
<pre data-role="codeBlock" data-info="" class="language-text"><code>/* YOUR CODE HERE */
	sd ra, 0(a0)
	sd sp, 8(a0)
	sd s0, 16(a0)
	sd s1, 24(a0)
	sd s2, 32(a0)
	sd s3, 40(a0)
	sd s4, 48(a0)
	sd s5, 56(a0)
	sd s6, 64(a0)
	sd s7, 72(a0)
	sd s8, 80(a0)
	sd s9, 88(a0)
	sd s10, 96(a0)
	sd s11, 104(a0)

	ld ra, 0(a1)
	ld sp, 8(a1)
	ld s0, 16(a1)
	ld s1, 24(a1)
	ld s2, 32(a1)
	ld s3, 40(a1)
	ld s4, 48(a1)
	ld s5, 56(a1)
	ld s6, 64(a1)
	ld s7, 72(a1)
	ld s8, 80(a1)
	ld s9, 88(a1)
	ld s10, 96(a1)
	ld s11, 104(a1)
	
</code></pre></details>
<details>
<summary>using threads</summary>
<p>在notxv6/ph.c中做如下修改即可：</p>
<pre data-role="codeBlock" data-info="c" class="language-c c"><code><span class="token class-name">pthread_mutex_t</span> lock<span class="token punctuation">[</span>NBUCKET<span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment">// 每个桶配一个锁</span>

<span class="token keyword keyword-static">static</span> 
<span class="token keyword keyword-void">void</span> <span class="token function">put</span><span class="token punctuation">(</span><span class="token keyword keyword-int">int</span> key<span class="token punctuation">,</span> <span class="token keyword keyword-int">int</span> value<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
  <span class="token keyword keyword-int">int</span> i <span class="token operator">=</span> key <span class="token operator">%</span> NBUCKET<span class="token punctuation">;</span>

  <span class="token function">pthread_mutex_lock</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>lock<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>       <span class="token comment">// 获取锁</span>
  
  <span class="token comment">// is the key already present?</span>
  <span class="token keyword keyword-struct">struct</span> <span class="token class-name">entry</span> <span class="token operator">*</span>e <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
  <span class="token keyword keyword-for">for</span> <span class="token punctuation">(</span>e <span class="token operator">=</span> table<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span> e <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">;</span> e <span class="token operator">=</span> e<span class="token operator">-&gt;</span>next<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword keyword-if">if</span> <span class="token punctuation">(</span>e<span class="token operator">-&gt;</span>key <span class="token operator">==</span> key<span class="token punctuation">)</span>
      <span class="token keyword keyword-break">break</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
  <span class="token keyword keyword-if">if</span><span class="token punctuation">(</span>e<span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token comment">// update the existing key.</span>
    e<span class="token operator">-&gt;</span>value <span class="token operator">=</span> value<span class="token punctuation">;</span>
  <span class="token punctuation">}</span> <span class="token keyword keyword-else">else</span> <span class="token punctuation">{</span>
    <span class="token comment">// the new is new.</span>
    <span class="token function">insert</span><span class="token punctuation">(</span>key<span class="token punctuation">,</span> value<span class="token punctuation">,</span> <span class="token operator">&amp;</span>table<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span> table<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
  <span class="token function">pthread_mutex_unlock</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>lock<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token comment">// 释放锁</span>
<span class="token punctuation">}</span>

<span class="token function">get</span><span class="token punctuation">(</span><span class="token keyword keyword-int">int</span> key<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
  <span class="token keyword keyword-int">int</span> i <span class="token operator">=</span> key <span class="token operator">%</span> NBUCKET<span class="token punctuation">;</span>
  <span class="token function">pthread_mutex_lock</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>lock<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>       <span class="token comment">// 获取锁</span>

  <span class="token keyword keyword-struct">struct</span> <span class="token class-name">entry</span> <span class="token operator">*</span>e <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
  <span class="token keyword keyword-for">for</span> <span class="token punctuation">(</span>e <span class="token operator">=</span> table<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span> e <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">;</span> e <span class="token operator">=</span> e<span class="token operator">-&gt;</span>next<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword keyword-if">if</span> <span class="token punctuation">(</span>e<span class="token operator">-&gt;</span>key <span class="token operator">==</span> key<span class="token punctuation">)</span> <span class="token keyword keyword-break">break</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
  <span class="token function">pthread_mutex_unlock</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>lock<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token comment">// 释放锁</span>
  <span class="token keyword keyword-return">return</span> e<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token comment">// main函数中添加初始化锁语句</span>
<span class="token keyword keyword-for">for</span><span class="token punctuation">(</span><span class="token keyword keyword-int">int</span> i <span class="token operator">=</span> <span class="token number">0</span> <span class="token punctuation">;</span> i <span class="token operator">&lt;</span> NBUCKET <span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>
    <span class="token function">pthread_mutex_init</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>lock<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 初始化锁</span>
</code></pre></details>
<details>
<summary>barrier</summary>
<p>在notxv6/barrier.c中修改barrier函数：</p>
<pre data-role="codeBlock" data-info="c" class="language-c c"><code><span class="token keyword keyword-static">static</span> <span class="token keyword keyword-void">void</span> 
<span class="token function">barrier</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
  <span class="token comment">// YOUR CODE HERE</span>
  <span class="token comment">//</span>
  <span class="token comment">// Block until all threads have called barrier() and</span>
  <span class="token comment">// then increment bstate.round.</span>
  <span class="token comment">//</span>

  <span class="token function">pthread_mutex_lock</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>bstate<span class="token punctuation">.</span>barrier_mutex<span class="token punctuation">)</span><span class="token punctuation">;</span>
  bstate<span class="token punctuation">.</span>nthread <span class="token operator">++</span><span class="token punctuation">;</span> 
  <span class="token comment">// 到达barrier的线程增加1</span>
  <span class="token comment">// 使用到公共变量bstate，需要在锁中进行</span>

  <span class="token keyword keyword-if">if</span><span class="token punctuation">(</span>bstate<span class="token punctuation">.</span>nthread <span class="token operator">==</span> nthread<span class="token punctuation">)</span><span class="token punctuation">{</span>
    bstate<span class="token punctuation">.</span>round<span class="token operator">++</span><span class="token punctuation">;</span>
    bstate<span class="token punctuation">.</span>nthread <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
    <span class="token function">pthread_cond_broadcast</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>bstate<span class="token punctuation">.</span>barrier_cond<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">pthread_mutex_unlock</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>bstate<span class="token punctuation">.</span>barrier_mutex<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
  <span class="token keyword keyword-else">else</span><span class="token punctuation">{</span>
    <span class="token function">pthread_cond_wait</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>bstate<span class="token punctuation">.</span>barrier_cond<span class="token punctuation">,</span> <span class="token operator">&amp;</span>bstate<span class="token punctuation">.</span>barrier_mutex<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">pthread_mutex_unlock</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>bstate<span class="token punctuation">.</span>barrier_mutex<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></details>
<h1 id="lec11">LEC11 </h1>

      </div>
      
      
    
    
    
    
    
    
  
    </body></html>